<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer Pro (Optimized)</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #sidebar {
      position: absolute; top: 0; left: 0;
      background: #f0f0f0;
      width: 260px; height: 100%;
      overflow-y: auto; border-right: 1px solid #ccc;
      padding: 10px; box-sizing: border-box; z-index: 10;
    }
    .containerBox {
      background: white; border: 1px solid #ccc;
      margin-bottom: 10px; padding: 10px;
    }
    .itemEntry {
      display: flex; align-items: center;
      gap: 4px; margin: 6px 0;
    }
    .itemEntry input[type="checkbox"] {
      transform: scale(1.2); margin-right: 6px;
    }
    #reportContainer {
      position: absolute;
      bottom: 0; left: 260px; right: 0;
      background: rgba(255,255,255,0.95);
      font-family: monospace;
      font-size: 13px; max-height: 35%;
      overflow-y: auto;
      display: flex; flex-wrap: wrap;
      border-top: 2px solid #000;
      z-index: 5;
    }
    .reportBox {
      border: 1px solid #ccc; padding: 10px; margin: 5px;
      flex: 1 1 220px; background: #fdfdfd; white-space: pre-wrap;
    }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Container Stuffing UI</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <h2>Container List</h2>
      <button onclick="addContainer()">+ Add Container</button>
      <div id="containers"></div>
      <button class="full-button" onclick="saveData()">🚚 Save to Visualizer</button>
    </aside>
    <main class="main-view">
      <iframe src="visualizer.html" width="100%" height="100%" style="border:0;"></iframe>
    </main>
  </div>

  <script>
    let containers = [{ type: '20GP', items: [] }];
    let modelLibrary = [
      { model: "FQ803", size: "20", length: 385, width: 255, height: 576 },
      { model: "FQ803", size: "21", length: 440, width: 255, height: 570 },
      { model: "FQ803", size: "29", length: 537, width: 300, height: 789 },
      { model: "FQ803", size: "24", length: 461, width: 295, height: 686 },
      { model: "FL688", size: "16", length: 375, width: 245, height: 422 },
      { model: "FL688", size: "17", length: 435, width: 245, height: 422 },
      { model: "FL688", size: "21", length: 421, width: 255, height: 566 },
      { model: "FL688", size: "24", length: 461, width: 295, height: 686 },
      { model: "FL688", size: "19", length: 424, width: 242, height: 577 },
      { model: "FL688", size: "29", length: 537, width: 300, height: 789 },
      { model: "FL688", size: "20", length: 385, width: 255, height: 576 },
      { model: "FL688", size: "31", length: 411, width: 350, height: 811 },
      { model: "FL688", size: "32", length: 581, width: 345, height: 883 },
      { model: "FL688", size: "29.5", length: 420, width: 385, height: 807 },
      { model: "FJ616", size: "16", length: 424, width: 228, height: 440 },
      { model: "FJ616", size: "20", length: 382, width: 262, height: 582 },
      { model: "FJ616", size: "24", length: 467, width: 285, height: 692 },
      { model: "FJ616", size: "19.5", length: 415, width: 235, height: 600 },
      { model: "FJ616", size: "29", length: 522, width: 292, height: 792 },
      { model: "FJ616", size: "31", length: 400, width: 340, height: 830 },
      { model: "FJ616", size: "32", length: 558, width: 325, height: 880 },
      { model: "FQ819-1", size: "21", length: 634, width: 419, height: 258 },
      { model: "FQ819-1", size: "26", length: 757, width: 469, height: 293 },
      { model: "FQ819-1", size: "29", length: 845, width: 519, height: 333 },
    ];

    const containerTypes = {
      '20GP': { label: '20FT (GP)' },
      '40GP': { label: '40FT (GP)' },
      '40HQ': { label: '40FT (HQ)' }
    };

    function addContainer() {
      containers.push({ type: '20GP', items: [] });
      render();
    }

<div id="sidebar">
  <h3>Container List</h3>
  <div id="containerList"></div>
</div>

<div id="reportContainer"></div>
<canvas id="threeCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
const containerSizeMap = {
  "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
  "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
  "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
};

let scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 50000);
camera.position.set(8000, 5000, 8000);
let renderer = new THREE.WebGLRenderer({ canvas: document.querySelector("#threeCanvas"), antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
let controls = new THREE.OrbitControls(camera, renderer.domElement);
let light = new THREE.AmbientLight(0xffffff, 1);
scene.add(light);

let mainGroup = new THREE.Group();
scene.add(mainGroup);
let boxMeshes = [], containerOffsets = [], data = [];
let needsRender = true;

function clearScene() {
  mainGroup.clear();
  boxMeshes = [];
}

function drawContainerWireframe(type, index) {
  const size = containerSizeMap[type];
  const material = new THREE.LineBasicMaterial({ color: 0x000000 });
  const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
  const edges = new THREE.EdgesGeometry(geometry);
  const line = new THREE.LineSegments(edges, material);
  const xOffset = index === 0 ? 0 : containerOffsets[index - 1] + containerSizeMap[data[index - 1].type].width + 200;
  containerOffsets[index] = xOffset + size.width;
  line.position.set(size.length / 2, size.height / 2, xOffset + size.width / 2);
  mainGroup.add(line);
  return { xOffset, size };
}

function getRotations(dim) {
  const { length, width, height } = dim;
  return [
    { l: length, w: width, h: height },
    { l: width, w: height, h: length },
    { l: height, w: length, h: width }
  ];
}

function smartPlaceBoxes(container, items, failedMap) {
  const unit = 10;
  const gridX = Math.floor(container.size.length / unit);
  const gridY = Math.floor(container.size.height / unit);
  const gridZ = Math.floor(container.size.width / unit);
  const grid = Array.from({ length: gridX }, () =>
    Array.from({ length: gridY }, () => Array(gridZ).fill(null))
  );
  let idCounter = 1;

  const maxHeightAtX = Array.from({ length: gridX }, (_, x) => {
    const step = 0.4;
    return Math.max(1, Math.floor(gridY - x * step));
  });

  items.sort((a, b) => {
    const volA = a.dimensions.l * a.dimensions.h * a.dimensions.w;
    const volB = b.dimensions.l * b.dimensions.h * b.dimensions.w;
    if (volA !== volB) return volB - volA;
    return (b.weight || 1) - (a.weight || 1);
  });

  items.forEach(item => {
    for (let q = 0; q < item.qty; q++) {
      let placed = false;
      const color = new THREE.Color(item.color || '#' + Math.floor(Math.random() * 16777215).toString(16));

      outerLoop:
      for (let y = 0; y < gridY; y++) {
        for (let x = 0; x < gridX; x++) {
          for (let z = 0; z < gridZ; z++) {
            const rotations = getRotations(item.dimensions);
            rotations.sort((a, b) => (a.l * a.h * a.w) - (b.l * b.h * b.w));

            for (let rot of rotations) {
              const dx = Math.ceil(rot.l / unit),
                    dy = Math.ceil(rot.h / unit),
                    dz = Math.ceil(rot.w / unit);
              if (x + dx > gridX || y + dy > gridY || z + dz > gridZ) continue;
              if (y + dy > maxHeightAtX[x]) continue;

              let canPlace = true;
              for (let xi = x; xi < x + dx && canPlace; xi++)
                for (let yi = y; yi < y + dy && canPlace; yi++)
                  for (let zi = z; zi < z + dz && canPlace; zi++)
                    if (grid[xi][yi][zi]) canPlace = false;

              if (y > 0) {
                for (let xi = x; xi < x + dx && canPlace; xi++) {
                  for (let zi = z; zi < z + dz && canPlace; zi++) {
                    const supportId = grid[xi][y - 1][zi];
                    if (!supportId || (grid[x][y - 1][z] && grid[x][y - 1][z] !== supportId)) {
                      canPlace = false;
                    }
                  }
                }
              }

              if (canPlace) {
                for (let xi = x; xi < x + dx; xi++)
                  for (let yi = y; yi < y + dy; yi++)
                    for (let zi = z; zi < z + dz; zi++)
                      grid[xi][yi][zi] = idCounter;

                const box = new THREE.Mesh(
                  new THREE.BoxGeometry(rot.l, rot.h, rot.w),
                  new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
                );
                box.userData.key = item.key;
                box.position.set(
                  x * unit + rot.l / 2,
                  y * unit + rot.h / 2,
                  container.xOffset + z * unit + rot.w / 2
                );
                mainGroup.add(box);
                boxMeshes.push(box);
                idCounter++;
                placed = true;
                break outerLoop;
              }
            }
          }
        }
      }

      if (!placed) {
        failedMap[item.key] = (failedMap[item.key] || 0) + 1;
    function removeContainer(index) {
      if (confirm("Hapus container ini?")) {
        containers.splice(index, 1);
        render();
      }
    }
  });
}

function renderFromData(payload) {
  clearScene(); document.getElementById("reportContainer").innerHTML = "";
  const containerDOM = document.getElementById("containerList");
  containerDOM.innerHTML = "";
  data = payload; containerOffsets = [];
    function addItem(containerIndex) {
      containers[containerIndex].items.push({ model: '', size: '', qty: 1, color: '#cccccc' });
      render();
    }

  payload.forEach((containerObj, cIndex) => {
    const container = drawContainerWireframe(containerObj.type, cIndex);
    const failedMap = {};
    const boxList = containerObj.items.map((i, idx) => {
      const key = `${i.model} ${i.size}" (C${cIndex + 1}-L${idx + 1})`;
      return { ...i, key };
    });
    smartPlaceBoxes(container, boxList, failedMap);
    function removeItem(containerIndex, itemIndex) {
      containers[containerIndex].items.splice(itemIndex, 1);
      render();
    }

    const box = document.createElement("div");
    box.className = "containerBox";
    box.innerHTML = `<strong>Container ${cIndex + 1}</strong><br>`;
    boxList.forEach(item => {
      const entry = document.createElement("div");
      entry.className = "itemEntry";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = item.key;
      checkbox.addEventListener("change", () => {
        applyFilterFromSidebar();
      });
      const label = document.createElement("label");
      label.textContent = item.key;
      entry.appendChild(checkbox);
      entry.appendChild(label);
      box.appendChild(entry);
    });
    containerDOM.appendChild(box);
    function updateValue(containerIndex, itemIndex, field, value) {
      containers[containerIndex].items[itemIndex][field] = field === 'qty' ? parseInt(value) || 0 : value;
      render();
    }

    let reportText = `Container ${cIndex + 1}: ${containerObj.type}
`;
    reportText += Object.keys(failedMap).length
      ? Object.entries(failedMap).map(([k, v]) => `❌ ${k} tidak muat ${v} pcs`).join("\n")
      : "✅ Semua box berhasil dimuat\n";
    const reportBox = document.createElement("div");
    reportBox.className = "reportBox"; reportBox.innerText = reportText;
    document.getElementById("reportContainer").appendChild(reportBox);
  });
    function updateType(containerIndex, value) {
      containers[containerIndex].type = value;
    }

  needsRender = true;
}
    function getSizesForModel(model) {
      return modelLibrary.filter(m => m.model === model).map(m => m.size);
    }

function applyFilterFromSidebar() {
  const activeKeys = Array.from(document.querySelectorAll(".itemEntry input:checked")).map(cb => cb.value);
  if (activeKeys.length === 0) {
    boxMeshes.forEach(b => b.material.opacity = 1);
  } else {
    boxMeshes.forEach(b => b.material.opacity = activeKeys.includes(b.userData.key) ? 1 : 0.05);
  }
  needsRender = true;
}
    function render() {
      const containerDiv = document.getElementById('containers');
      containerDiv.innerHTML = '';
      containers.forEach((container, ci) => {
        const box = document.createElement('div');
        box.className = 'container-box';

        const options = Object.entries(containerTypes).map(([key, data]) =>
          `<option value="${key}" ${key === container.type ? 'selected' : ''}>${data.label}</option>`).join('');

        box.innerHTML = `<h3>Container ${ci + 1}</h3>
          <label>Type: <select onchange="updateType(${ci}, this.value); render()">${options}</select></label>
          <button onclick="removeContainer(${ci})">- Remove Container</button>`;

        container.items.forEach((item, ii) => {
          const modelOptions = modelLibrary.map(m => m.model).filter((v, i, a) => a.indexOf(v) === i).map(v => `<option value="${v}">`).join('');
          const sizeOptions = getSizesForModel(item.model).map(v => `<option value="${v}">`).join('');

          box.innerHTML += `
            <div class="row">
              <input list="models-${ci}-${ii}" placeholder="Model" value="${item.model}" onchange="updateValue(${ci}, ${ii}, 'model', this.value)" />
              <datalist id="models-${ci}-${ii}">${modelOptions}</datalist>

              <input list="sizes-${ci}-${ii}" placeholder="Size" value="${item.size}" onchange="updateValue(${ci}, ${ii}, 'size', this.value)" />
              <datalist id="sizes-${ci}-${ii}">${sizeOptions}</datalist>

              <input type="number" value="${item.qty}" onchange="updateValue(${ci}, ${ii}, 'qty', this.value)" />
              <input type="color" value="${item.color}" onchange="updateValue(${ci}, ${ii}, 'color', this.value)" />
              <button onclick="removeItem(${ci}, ${ii})">&times;</button>
            </div>
          `;
        });

        box.innerHTML += `<button onclick="addItem(${ci})">+ Add List</button>`;
        containerDiv.appendChild(box);
      });
    }

window.addEventListener("message", (event) => {
  if (event.data?.type === "RENDER_CONTAINER") renderFromData(event.data.payload);
});
    function saveData() {
      const enrichedData = containers.map(c => ({
        type: containerTypes[c.type].label,
        items: c.items.map(item => {
          const match = modelLibrary.find(m => m.model === item.model && m.size === item.size);
          return {
            ...item,
            dimensions: match ? {
              length: match.length,
              width: match.width,
              height: match.height
            } : { length: 0, width: 0, height: 0 }
          };
        })
      }));

      const iframe = document.querySelector("iframe");
      iframe.contentWindow.postMessage({
        type: "RENDER_CONTAINER",
        payload: enrichedData
      }, "*");
    }

function animate() {
  requestAnimationFrame(animate);
  if (needsRender) {
    controls.update();
    renderer.render(scene, camera);
    needsRender = false;
  }
}
animate();
</script>
    render();
  </script>
</body>
</html>

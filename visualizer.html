Beres. Ini versi upgrade yang **mampu mix orientasi otomatis** (kombinasi sampai 3 orientasi, mis. 3V+1H) tanpa menghilangkan fungsi lain. Aku cuma ubah algoritma di `shelfPackMixed`, `pickBestItemForWidth` (tambah exclude), dan `bestRowMixWidth` (bruteforce terkontrol untuk pasang kombinasi orientasi agar sisa lebar minimum). Struktur & UI tetap.

> Tempelkan seluruh file ini menggantikan punyamu sekarang.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer – Mixed-Orientation Shelf Packing</title>
  <style>
    :root {
      --panel-bg: #f7f7f8;
      --border: #d8d8de;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { display: block; }

    #sidebar {
      position: absolute; inset: 0 auto 0 0; width: 280px; background: var(--panel-bg);
      border-right: 1px solid var(--border); z-index: 10; box-sizing: border-box; padding: 12px;
      overflow-y: auto;
    }
    #sidebar h3 { margin: 0 0 8px; }
    .containerBox { background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 10px; margin-bottom: 10px; }
    .muted { color: #666; font-size: 12px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .tag { border: 1px solid var(--border); border-radius: 999px; padding: 2px 8px; font-size: 12px; background: #fff; }

    #reportContainer {
      position: absolute; left: 280px; right: 0; bottom: 0; background: rgba(255,255,255,0.96);
      border-top: 2px solid #000; z-index: 5; font-family: var(--mono); font-size: 12px;
      max-height: 35%; overflow: auto; display: flex; flex-wrap: wrap; gap: 8px; padding: 8px;
    }
    .reportBox { border: 1px solid var(--border); background: #fff; border-radius: 8px; padding: 10px; white-space: pre-wrap; flex: 1 1 280px; }

    #topbar {
      position: absolute; left: 280px; right: 0; top: 0; height: 46px; background: rgba(255,255,255,0.9);
      border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; padding: 0 10px; z-index: 8;
      backdrop-filter: blur(4px);
    }
    #topbar button, #topbar select {
      border: 1px solid var(--border); background: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 13px;
    }
    #topbar .spacer { flex: 1; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Container List</h3>
    <div id="containerList"></div>
  </div>
  <div id="topbar">
    <button id="btnRenderDummy" title="Render contoh payload">Render Dummy</button>
    <button id="btnClearCache" title="Hapus cache lokal">Clear Cache</button>
    <label class="muted">Unit mm</label>
    <div class="spacer"></div>
    <span class="muted">Tip: Kirim payload via <code>postMessage</code> { type: "RENDER_CONTAINER", payload }</span>
  </div>
  <div id="reportContainer"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ------------------ CONFIG ------------------
  const GAP = 2; // mm, celah visual minimal agar tidak tembus outline
  const containerSizeMap = {
    "20FT (GP)": { length: 6058, width: 2438, height: 2591 },
    "40FT (GP)": { length: 12192, width: 2438, height: 2591 },
    "40FT (HQ)": { length: 12192, width: 2438, height: 2896 }
  };

  // ------------------ THREE SETUP ------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
  camera.position.set(9000, 6000, 9000);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;

  const ambient = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  let boxMeshes = [], containerOffsets = [], data = [];

  // ------------------ UTIL ------------------
  function hashPayload(payload) {
    try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0, 160); }
    catch { return String(Date.now()); }
  }
  function clearScene() { mainGroup.clear(); boxMeshes = []; }

  function withOutline(mesh, color = 0x000000) {
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color }));
    mesh.add(line);
    return mesh;
  }

  function addBox(dim, pos, color, key) {
    const geometry = new THREE.BoxGeometry(dim.l - GAP, dim.h - GAP, dim.w - GAP);
    const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), transparent: false, opacity: 0.95 });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(pos[0], pos[1], pos[2]);
    box.userData.key = key;
    withOutline(box, 0x000000);
    mainGroup.add(box);
    boxMeshes.push(box);
  }

  function drawFromCache(boxDataArray, containers) {
    clearScene();
    containerOffsets = [];
    containers.forEach((c, i) => drawContainerWireframe(c.type, i));
    boxDataArray.forEach(d => addBox({ l: d.l, h: d.h, w: d.w }, d.position, d.color, d.key));
  }

  // ------------------ CORE RENDER ------------------
  function renderFromData(payload, { useCache = true } = {}) {
    const reportEl = document.getElementById('reportContainer');
    const listEl = document.getElementById('containerList');

    const hash = hashPayload(payload);
    const cacheKey = `cachedBoxes_${hash}`;

    if (useCache) {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const parsed = JSON.parse(cached);
        drawFromCache(parsed.boxes, parsed.containers);
        listEl.innerHTML = buildSidebar(payload);
        reportEl.innerHTML = buildReport(parsed.stats);
        return;
      }
    }

    clearScene(); reportEl.innerHTML = ''; listEl.innerHTML = '';
    data = payload; containerOffsets = [];

    const allBoxes = []; const globalStats = [];

    payload.forEach((containerObj, cIndex) => {
      const container = drawContainerWireframe(containerObj.type, cIndex);
      const failedMap = {};
      const boxList = containerObj.items.map((i, idx) => ({
        ...i,
        key: `${i.model} ${i.size}\" (C${cIndex+1}-L${idx+1})`
      }));

      const placed = shelfPackMixed(container, boxList, failedMap);
      allBoxes.push(...placed.drawn);

      globalStats.push({
        containerIndex: cIndex+1,
        type: containerObj.type,
        placed: placed.countPlaced,
        failed: placed.countFailed,
        failedMap
      });
    });

    localStorage.setItem(cacheKey, JSON.stringify({ boxes: allBoxes, containers: payload.map(p=>({type:p.type})) , stats: globalStats }));

    listEl.innerHTML = buildSidebar(payload);
    reportEl.innerHTML = buildReport(globalStats);
  }

  // ------------------ PACKING: MIXED-ORIENTATION SHELF ------------------
  function shelfPackMixed(container, items, failedMap) {
    const size = container.size;
    const drawn = [];
    let countPlaced = 0, countFailed = 0;
    const randomColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');

    // Urutkan item dari volume terbesar
    items.sort((a, b) => {
      const va = a.dimensions.l * a.dimensions.w * a.dimensions.h;
      const vb = b.dimensions.l * b.dimensions.w * b.dimensions.h;
      return vb - va;
    });

    let y = 0;
    while (true) {
      const remain = items.reduce((s,i)=>s+(+i.qty||0),0);
      if (!remain) break;

      // Cari tinggi minimum yang bisa dipakai di layer ini
      let minH = Infinity;
      items.forEach(it=>{
        if ((it.qty||0) <= 0) return;
        getAllRotations(it.dimensions).forEach(r=>{
          if (r.h + GAP <= size.height - y) minH = Math.min(minH, r.h);
        });
      });
      if (!isFinite(minH)) break;

      let shelfTopY = y;
      let z = 0;
      let progressInWidth = false;

      while (z < size.width - GAP) {
        const tried = new Set();
        let candidate = pickBestItemForWidth(items, size.width - z, size.height - y, tried);
        if (!candidate) break; // Tidak ada item yang muat di lebar tersisa

        // Cari kombinasi orientasi terbaik untuk mengisi lebar (mix otomatis)
        let mix = bestRowMixWidth(candidate.item.dimensions, size.width - z, size.height - y, candidate.item.qty);
        // Jika kombinasi untuk item ini tidak ada (karena qty/tinggi/lebar), coba item lain tanpa mengubah qty item sekarang
        while ((!mix || mix.cols.length === 0) && candidate) {
          tried.add(candidate.item.key);
          candidate = pickBestItemForWidth(items, size.width - z, size.height - y, tried);
          if (candidate) mix = bestRowMixWidth(candidate.item.dimensions, size.width - z, size.height - y, candidate.item.qty);
        }
        if (!candidate || !mix || mix.cols.length === 0) break;

        const rowHeight = mix.rowHeight;
        const shelfHeight = Math.max(minH, rowHeight);
        if (y + shelfHeight > size.height) break;

        for (const col of mix.cols) {
          if (candidate.item.qty <= 0) {
            // cari item lagi yang identik dimensi? tetap boleh item sama tipe — tapi kalau habis kita stop kolom
            break;
          }
          const rot = col.rot;
          const colWidth = rot.w + GAP;

          let countAlongX = Math.floor((size.length + GAP) / (rot.l + GAP));
          if (countAlongX < 1) countAlongX = 1;

          // tempatkan sepanjang X
          const placeCount = Math.min(countAlongX, candidate.item.qty);
          if (placeCount <= 0) continue;

          for (let i = 0; i < placeCount; i++) {
            const x = (rot.l + GAP) * i;
            const pos = [
              container.xOffset + (rot.l/2) + x,
              y + (rot.h/2),
              z + (rot.w/2)
            ];
            const color = candidate.item.color || randomColor();
            addBox({ l: rot.l, h: rot.h, w: rot.w }, pos, color, candidate.item.key);
            drawn.push({ l: rot.l, h: rot.h, w: rot.w, color, position: pos, key: candidate.item.key });
            countPlaced++;
          }
          candidate.item.qty -= placeCount;
          z += colWidth;
          progressInWidth = true;
          if (z > size.width - GAP) break;
        }

        shelfTopY = Math.max(shelfTopY, y + shelfHeight);
      }

      if (!progressInWidth) break;
      y = shelfTopY;
      if (y > size.height - GAP) break;
    }

    // Hitung yang gagal
    items.forEach(it=>{
      const left = (+it.qty||0);
      if (left > 0) {
        failedMap[it.key] = (failedMap[it.key]||0) + left;
        countFailed += left;
      }
    });

    return { drawn, countPlaced, countFailed };
  }

  // Pilih item yang paling cocok untuk sisa lebar + tinggi (qty>0), dengan exclude set
  function pickBestItemForWidth(items, widthRemain, heightRemain, excludeSet = new Set()) {
    let best = null, bestScore = -1;
    for (const it of items) {
      if ((it.qty||0) <= 0) continue;
      if (excludeSet.has(it.key)) continue;
      const rots = getAllRotations(it.dimensions).filter(r => r.w + GAP <= widthRemain && r.h + GAP <= heightRemain);
      if (!rots.length) continue;
      // skor: lebar terpakai maksimum * prioritas qty
      const maxW = Math.max(...rots.map(r=>r.w));
      const score = maxW + Math.min(it.qty, 100) * 1e-3;
      if (score > bestScore) { bestScore = score; best = { item: it, rots }; }
    }
    return best;
  }

  // Cari kombinasi sampai 3 orientasi untuk mengisi lebar (Z) seefisien mungkin
  // Mengembalikan { cols: [ { rot }, ... ], rowHeight }
  function bestRowMixWidth(dim, widthAvail, heightAvail, qtyAvail = Infinity) {
    // Semua rotasi yang muat tinggi & lebar satu kolom
    const baseRots = getAllRotations(dim).filter(r => r.h + GAP <= heightAvail && r.w + GAP <= widthAvail);
    if (!baseRots.length) return null;

    // Ambil sampai 4 orientasi paling lebar supaya kombinasi tidak meledak
    const rots = [...baseRots].sort((a,b)=>b.w-a.w).slice(0,4);

    let best = null;

    // Precompute tile widths
    const tiles = rots.map(r => ({ rot: r, tile: r.w + GAP }));

    // Target: isi selebar mungkin (minim leftover). Cari kombinasi counts untuk max 3 jenis.
    // Batas atas count tiap jenis
    const maxCountFor = (tile) => Math.max(0, Math.floor((widthAvail + GAP) / tile)); // +GAP agar konsisten dengan loop z += w+GAP

    // Coba 1-orientasi
    for (let i = 0; i < tiles.length; i++) {
      const t1 = tiles[i];
      const c1max = Math.min(maxCountFor(t1.tile), qtyAvail);
      if (c1max <= 0) continue;
      const used1 = c1max * t1.tile;
      const leftover1 = widthAvail - used1;
      const cols1 = Array.from({length:c1max}, _=>({rot:t1.rot}));
      registerCandidate(cols1);
    }

    // Coba 2-orientasi
    for (let i = 0; i < tiles.length; i++) {
      for (let j = i; j < tiles.length; j++) { // boleh sama
        const t1 = tiles[i], t2 = tiles[j];
        const c1max = Math.min(maxCountFor(t1.tile), qtyAvail);
        const c2max = Math.min(maxCountFor(t2.tile), qtyAvail);
        for (let c1 = c1max; c1 >= 0; c1--) {
          const used1 = c1 * t1.tile;
          if (used1 > widthAvail) continue;
          const remainW = widthAvail - used1;
          const c2 = Math.min(Math.floor(remainW / t2.tile), qtyAvail - c1);
          if (c2 < 0) continue;
          const used = used1 + c2 * t2.tile;
          const cols = [
            ...Array.from({length:c1}, _=>({rot:t1.rot})),
            ...Array.from({length:c2}, _=>({rot:t2.rot}))
          ];
          registerCandidate(cols);
        }
      }
    }

    // Coba 3-orientasi
    for (let i = 0; i < tiles.length; i++) {
      for (let j = i; j < tiles.length; j++) {
        for (let k = j; k < tiles.length; k++) {
          const t1 = tiles[i], t2 = tiles[j], t3 = tiles[k];
          const c1max = Math.min(maxCountFor(t1.tile), qtyAvail);
          for (let c1 = c1max; c1 >= 0; c1--) {
            const used1 = c1 * t1.tile;
            if (used1 > widthAvail) continue;
            const r1 = widthAvail - used1;

            const c2max = Math.min(Math.floor(r1 / t2.tile), qtyAvail - c1);
            for (let c2 = c2max; c2 >= 0; c2--) {
              const used2 = used1 + c2 * t2.tile;
              if (used2 > widthAvail) continue;
              const r2 = widthAvail - used2;

              const c3 = Math.min(Math.floor(r2 / t3.tile), qtyAvail - c1 - c2);
              if (c3 < 0) continue;

              const cols = [
                ...Array.from({length:c1}, _=>({rot:t1.rot})),
                ...Array.from({length:c2}, _=>({rot:t2.rot})),
                ...Array.from({length:c3}, _=>({rot:t3.rot}))
              ];
              registerCandidate(cols);
            }
          }
        }
      }
    }

    function registerCandidate(cols) {
      if (!cols.length) return;
      const used = cols.reduce((s,c)=> s + (c.rot.w + GAP), 0);
      if (used > widthAvail + 1e-6) return;
      const leftover = widthAvail - used;
      const rowHeight = Math.max(...cols.map(c => c.rot.h));
      if (rowHeight + GAP > heightAvail) return;
      const score = used - leftover * 10 - rowHeight * 1e-3; // utamakan lebar terpakai, penalti leftover, prefer height kecil tipis
      if (!best || score > best.score) {
        best = { cols, rowHeight, score };
      }
    }

    // fallback greedy kalau tidak ada kombinasi yang lolos (harusnya jarang)
    if (!best) {
      let z = 0;
      const greedyCols = [];
      const ro = [...rots].sort((a,b)=>b.w-a.w);
      while (z + GAP <= widthAvail) {
        const fit = ro.find(r => r.w + GAP <= widthAvail - z);
        if (!fit) break;
        greedyCols.push({ rot: fit });
        z += fit.w + GAP;
      }
      if (greedyCols.length) {
        best = { cols: greedyCols, rowHeight: Math.max(...greedyCols.map(c=>c.rot.h)), score: z };
      }
    }

    return best;
  }

  function getAllRotations(dim) {
    const L = dim.length ?? dim.l, W = dim.width ?? dim.w, H = dim.height ?? dim.h;
    const uniq = new Set();
    const out = [];
    const perms = [
      { l:L, w:W, h:H }, { l:L, w:H, h:W },
      { l:W, w:L, h:H }, { l:W, w:H, h:L },
      { l:H, w:L, h:W }, { l:H, w:W, h:L }
    ];
    for (const p of perms) {
      const k = `${p.l}|${p.w}|${p.h}`;
      if (!uniq.has(k)) { uniq.add(k); out.push(p); }
    }
    // urutkan orientasi: tinggi dulu (kecil ke besar), lalu footprint (besar ke kecil)
    out.sort((a,b)=> (a.h-b.h) || ((b.l*b.w)-(a.l*a.w)) );
    return out;
  }

  // ------------------ CONTAINER WIREFRAME ------------------
  function drawContainerWireframe(type, index) {
    const size = containerSizeMap[type];
    if (!size) throw new Error(`Unknown container type: ${type}`);

    const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));

    const xOffset = index === 0 ? 0 : containerOffsets[index-1] + containerSizeMap[data[index-1].type].length + 500;
    containerOffsets[index] = xOffset + size.length;

    line.position.set(xOffset + size.length/2, size.height/2, size.width/2);
    mainGroup.add(line);

    const gridHelper = new THREE.GridHelper(size.length, Math.max(2, Math.round(size.length/500)), 0x999999, 0xdddddd);
    gridHelper.rotation.x = Math.PI/2;
    gridHelper.position.set(xOffset + size.length/2, 1, size.width/2);
    mainGroup.add(gridHelper);

    return { xOffset, size };
  }

  // ------------------ UI BUILDERS ------------------
  function buildSidebar(payload) {
    let html = '';
    payload.forEach((c, i) => {
      const s = containerSizeMap[c.type];
      html += `
        <div class="containerBox">
          <div class="row"><strong>C${i+1}</strong> <span class="tag">${c.type}</span></div>
          <div class="muted">${s.length}×${s.width}×${s.height} mm</div>
          <div class="muted">Items: ${c.items.reduce((a,b)=>a+(b.qty||1),0)}</div>
        </div>
      `;
    });
    return html;
  }

  function buildReport(stats) {
    let html = '';
    stats.forEach(s => {
      html += `
        <div class="reportBox">
        C${s.containerIndex} [${s.type}]
        Placed: ${s.placed} | Failed: ${s.failed}
${Object.keys(s.failedMap).length ? '\nFailed detail:\n' + Object.entries(s.failedMap).map(([k,v])=>`- ${k}: ${v}`).join('\n') : ''}
        </div>
      `;
    });
    return html;
  }

  // ------------------ MESSAGE & DUMMY ------------------
  window.addEventListener('message', (event) => {
    if (event?.data?.type === 'RENDER_CONTAINER') {
      try { renderFromData(event.data.payload); }
      catch (e) { console.error(e); }
    }
  });

  document.getElementById('btnRenderDummy').addEventListener('click', () => renderDummy());
  document.getElementById('btnClearCache').addEventListener('click', () => { localStorage.clear(); alert('Cache cleared'); });

  function renderDummy() {
    // contoh 1 tipe box (kasus umum 471 pcs) + variasi lain
    const dummyPayload = [
      {
        type: '40FT (HQ)',
        items: [
          // ganti dimensi ini sesuai actual box kamu untuk melihat mix 3V + 1H otomatis
          { model: 'FQ803', size: 24, qty: 600, dimensions: { l: 600, w: 400, h: 300 }, color: '#F472B6' },
          { model: 'Tambahan', size: 22, qty: 40, dimensions: { l: 500, w: 500, h: 300 }, color: '#60A5FA' }
        ]
      }
    ];
    renderFromData(dummyPayload, { useCache: false });
  }

  window.addEventListener('DOMContentLoaded', () => {
    if (window.top === window.self) renderDummy();
  });

  // ------------------ RESIZE & ANIMATE ------------------
  function onResize() {
    const w = window.innerWidth; const h = window.innerHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
  </script>
</body>
</html>
```

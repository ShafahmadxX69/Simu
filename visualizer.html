<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer â€“ Super Smooth</title>
  <style>
    :root { --sidebar-w: 260px; }
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; font-family: system-ui, Arial, sans-serif; background:#fff; }
    #sidebar {
      position: absolute; inset: 0 auto 35% 0; width: var(--sidebar-w);
      background: #f6f6f6; border-right: 1px solid #ddd; z-index: 10; overflow: auto;
      padding: 10px; box-sizing: border-box; font-size: 14px;
    }
    #sidebar h3 { margin: 6px 0 10px; font-weight: 700; }
    .containerBox { background: #fff; border: 1px solid #ddd; padding: 8px; margin-bottom: 8px; border-radius: 6px; }
    #reportContainer {
      position: absolute; left: var(--sidebar-w); right: 0; bottom: 0; height: 35%;
      background: rgba(255,255,255,0.98); border-top: 2px solid #000; z-index: 5; display: flex; flex-wrap: wrap; overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px;
    }
    .reportBox { flex: 1 1 240px; min-width: 240px; padding: 10px; margin: 6px; border: 1px solid #ddd; background: #fff; white-space: pre-wrap; border-radius: 6px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="sidebar"><h3>Daftar Kontainer</h3><div id="containerList"></div></div>
  <div id="reportContainer"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ====== KONFIGURASI KONTainer ======
  const containerSizeMap = {
    "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
    "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
    "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
  };

  // ====== SCENE ======
  const canvas = document.getElementById('threeCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.75));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = false; // performa

  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#ffffff');

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 200000);
  camera.position.set(9000, 6200, 9000);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.07; controls.rotateSpeed = 0.5; controls.zoomSpeed = 0.7;
  controls.addEventListener('change', renderOnce);

  // Pencahayaan hemat
  scene.add(new THREE.HemisphereLight(0xffffff, 0xe0e0e0, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 0.4);
  dir.position.set(1,2,1).multiplyScalar(5000); scene.add(dir);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  // ====== UTIL ======
  const unit = 10; // grid 1 cm = 10 mm; naikkan untuk mempercepat
  function ceilDiv(a,b){ return Math.ceil(a/b); }
  function hashPayload(payload){ return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0,100); }

  function clearScene(){
    while(mainGroup.children.length) mainGroup.remove(mainGroup.children[0]);
    mainGroup.clear();
  }

  function drawContainerWireframe(type, xOffset){
    const size = containerSizeMap[type];
    const geo = new THREE.EdgesGeometry(new THREE.BoxGeometry(size.length, size.height, size.width));
    const line = new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0x9aa0a6 }));
    line.position.set(size.length/2, size.height/2, xOffset + size.width/2);
    scene.add(line);
    // lantai (opsional untuk orientasi)
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(size.length, size.width), new THREE.MeshBasicMaterial({color:'#d6a34b'}));
    floor.rotation.x = -Math.PI/2; floor.position.set(size.length/2, 0.1, xOffset + size.width/2); floor.renderOrder=-1;
    scene.add(floor);
    return { size, xOffset };
  }

  // ====== PENEMPATAN: STAIR-STACK + BESAR DI BAWAH ======
  function getRotations(dim){ // 3 orientasi khas
    return [
      { l: dim.length, w: dim.width, h: dim.height },
      { l: dim.width,  w: dim.height, h: dim.length },
      { l: dim.height, w: dim.length, h: dim.width }
    ];
  }

  function stairMaxHeightProfile(lenCells, containerHeight){
    // profil tangga: tinggi maksimal menurun seiring sumbu X (arah panjang)
    const stepCells = 8;      // lebar 1 anak tangga (grid-cell)
    const stepDrop = 80;      // turun 80 mm per step (atur sesuai kebutuhan)
    const maxH = new Array(lenCells).fill(containerHeight);
    let current = containerHeight;
    for(let x=0;x<lenCells;x++){
      if(x>0 && x % stepCells === 0){ current = Math.max(0, current - stepDrop); }
      maxH[x] = current;
    }
    return maxH; // mm
  }

  function placeBoxesInContainer(container, items){
    const { length, width, height } = container.size;
    const gx = ceilDiv(length, unit), gz = ceilDiv(width, unit);

    // heightmap[y] per (x,z) mm; mulai 0 (lantai)
    const heightMap = Array.from({length: gx}, () => new Array(gz).fill(0));
    const maxHProfile = stairMaxHeightProfile(gx, height);

    // Urutkan: volume besar dulu (lebih berat ~ proxy) lalu dasar area besar
    const expanded = [];
    items.forEach(i => {
      for(let q=0;q<i.qty;q++) expanded.push(i);
    });
    expanded.sort((a,b)=>{
      const va = a.dimensions.length*a.dimensions.height*a.dimensions.width;
      const vb = b.dimensions.length*b.dimensions.height*b.dimensions.width;
      if(vb!==va) return vb-va;
      const aa = a.dimensions.length*a.dimensions.width;
      const ab = b.dimensions.length*b.dimensions.width;
      return ab-aa;
    });

    const placements = [];

    for(const item of expanded){
      let best = null;
      const rotations = getRotations(item.dimensions);
      for(const rot of rotations){
        const dx = ceilDiv(rot.l, unit), dz = ceilDiv(rot.w, unit), dh = rot.h;
        if(rot.l>length || rot.w>width || rot.h>height) continue; // terlalu besar
        for(let x=0; x<=gx-dx; x++){
          for(let z=0; z<=gz-dz; z++){
            // cari ketinggian maksimum di area (x..x+dx-1, z..z+dz-1)
            let base = 0, allowed = Infinity, ok = true;
            for(let xi=x; xi<x+dx && ok; xi++){
              // profil tangga membatasi puncak di kolom x ini
              const stairMax = maxHProfile[xi];
              for(let zi=z; zi<z+dz; zi++){
                base = Math.max(base, heightMap[xi][zi]);
                allowed = Math.min(allowed, stairMax);
                if(base + dh > stairMax) { ok = false; break; }
              }
            }
            if(!ok) continue;
            // kandidat: tempatkan di base terendah yang muat
            const score = base; // makin kecil makin bagus (lebih bawah = stabil)
            if(!best || score < best.score){ best = { x, z, rot, base, score }; }
          }
        }
      }
      if(best){
        const {x,z,rot,base} = best;
        // update heightMap
        const dx = ceilDiv(rot.l, unit), dz = ceilDiv(rot.w, unit);
        for(let xi=x; xi<x+dx; xi++) for(let zi=z; zi<z+dz; zi++) heightMap[xi][zi] = base + rot.h;
        // posisi dunia
        const pos = [ x*unit + rot.l/2, base + rot.h/2, container.xOffset + z*unit + rot.w/2 ];
        placements.push({ l: rot.l, h: rot.h, w: rot.w, position: pos, color: item.color || null, key: item.model+" "+item.size+'"' });
      } else {
        // gagal ditempatkan
        placements.push({ failed: true, key: item.model+" "+item.size+'"' });
      }
    }
    return placements;
  }

  // ====== RENDER INSTANCED (super cepat) ======
  function renderInstancedBoxes(allBoxes){
    // satu InstancedMesh untuk semua box; gunakan per-instance color
    const boxGeo = new THREE.BoxGeometry(1,1,1);
    const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.6, metalness: 0.0 });
    const mesh = new THREE.InstancedMesh(boxGeo, mat, allBoxes.length);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    const color = new THREE.Color();
    const dummy = new THREE.Object3D();

    allBoxes.forEach((b, idx) => {
      dummy.position.set(b.position[0], b.position[1], b.position[2]);
      dummy.scale.set(b.l, b.h, b.w);
      dummy.updateMatrix();
      mesh.setMatrixAt(idx, dummy.matrix);
      color.set(b.color || randomPastel(idx));
      mesh.setColorAt(idx, color);
    });
    mesh.instanceColor.needsUpdate = true;
    mainGroup.add(mesh);
    renderOnce();
  }

  function randomPastel(seed){
    // deterministik agar sama untuk cache
    const x = Math.sin(seed+1)*10000; const r = x - Math.floor(x);
    const h = r*360; const s = 0.55, l = 0.65;
    return new THREE.Color().setHSL(h/360, s, l);
  }

  function drawFromCache(boxDataArray){
    clearScene();
    renderInstancedBoxes(boxDataArray);
  }

  function renderFromData(payload){
    const hash = hashPayload(payload);
    const cacheKey = `cachedBoxes_${hash}`;
    const cached = localStorage.getItem(cacheKey);
    if(cached){
      drawFromCache(JSON.parse(cached));
      return;
    }

    clearScene();
    document.getElementById('reportContainer').innerHTML = '';
    document.getElementById('containerList').innerHTML = '';

    // offset antar kontainer: deret di sumbu Z
    let xOffsetAccum = 0;
    const allBoxes = [];
    const report = [];

    payload.forEach((containerObj, idx) => {
      const wire = drawContainerWireframe(containerObj.type, xOffsetAccum);
      xOffsetAccum += wire.size.width + 200; // jarak antar kontainer

      // siapkan items (key, qty)
      const items = containerObj.items.map((i)=>({
        ...i,
        key: `${i.model} ${i.size}\" (C${idx+1})`,
        dimensions: {
          length: i.dimensions.l ?? i.dimensions.length,
          width:  i.dimensions.w ?? i.dimensions.width,
          height: i.dimensions.h ?? i.dimensions.height,
        }
      }));

      const placed = placeBoxesInContainer(wire, items);
      const placedOk = placed.filter(p=>!p.failed);
      const failed = placed.filter(p=>p.failed).length;
      allBoxes.push(...placedOk);

      // ringkasan per kontainer
      report.push({ idx: idx+1, type: containerObj.type, placed: placedOk.length, failed });
    });

    localStorage.setItem(cacheKey, JSON.stringify(allBoxes));
    renderInstancedBoxes(allBoxes);
    writeReport(report);
  }

  function writeReport(report){
    const c = document.getElementById('reportContainer');
    c.innerHTML = '';
    report.forEach(r => {
      const div = document.createElement('div');
      div.className = 'reportBox';
      div.textContent = `Kontainer ${r.idx} (${r.type})\nBerhasil ditempatkan: ${r.placed}\nGagal: ${r.failed}`;
      c.appendChild(div);
    });
  }

  // ====== RENDER LOOP HEMAT ======
  function renderOnce(){ renderer.render(scene, camera); }
  renderOnce();

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight); renderOnce();
  });

  // Pesan dari parent (tetap kompatibel)
  window.addEventListener('message', (event)=>{
    if(event.data?.type === 'RENDER_CONTAINER'){ renderFromData(event.data.payload); }
  });

  // ====== DEMO OPSIONAL: kirim payload dummy saat halaman dibuka ======
  // Hapus blok ini jika Anda hanya ingin merender dari postMessage
  const demo = false; // set true untuk contoh cepat
  if(demo){
    const payload = [{
      type: '40FT (HQ)',
      items: [
        { model:'A', size: 48, qty: 28, color:'#e77975', dimensions:{ length: 600, width: 400, height: 400 } },
        { model:'B', size: 32, qty: 30, color:'#e77975', dimensions:{ length: 600, width: 400, height: 300 } },
        { model:'C', size: 24, qty: 10, color:'#e77975', dimensions:{ length: 400, width: 300, height: 300 } }
      ]
    }];
    renderFromData(payload);
  }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smart 3D Box Placement</title>
  <style>
    body { margin: 0; overflow: hidden; background: #fff3f7; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#ffeef5');

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(40, 40, 60);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.AmbientLight(0xffffff, 1.2);
    scene.add(light);

    // Kontainer grid ukuran (X, Y, Z)
    const gridX = 10, gridY = 6, gridZ = 10;
    const grid = Array(gridX).fill().map(() =>
      Array(gridY).fill().map(() => Array(gridZ).fill(null))
    );

    const boxSize = 2;

    const boxes = [
      { dx: 2, dy: 2, dz: 2, color: '#F88', label: 'A' },
      { dx: 2, dy: 2, dz: 2, color: '#8F8', label: 'B' },
      { dx: 2, dy: 2, dz: 2, color: '#88F', label: 'C' },
      { dx: 2, dy: 2, dz: 2, color: '#FF8', label: 'D' },
      { dx: 2, dy: 2, dz: 2, color: '#8FF', label: 'E' },
      { dx: 2, dy: 2, dz: 2, color: '#F8F', label: 'F' },
      { dx: 2, dy: 2, dz: 2, color: '#CCC', label: 'G' },
      { dx: 2, dy: 2, dz: 2, color: '#FAA', label: 'H' },
      { dx: 2, dy: 2, dz: 2, color: '#AAF', label: 'I' },
      { dx: 2, dy: 2, dz: 2, color: '#AFA', label: 'J' },
    ];

    function isAreaEmpty(grid, x, y, z, dx, dy, dz) {
      for (let i = x; i < x + dx; i++) {
        for (let j = y; j < y + dy; j++) {
          for (let k = z; k < z + dz; k++) {
            if (grid[i]?.[j]?.[k]) return false;
          }
        }
      }
      return true;
    }

    function isSupported(grid, x, y, z, dx, dy, dz) {
      if (y === 0) return true;
      for (let i = x; i < x + dx; i++) {
        for (let k = z; k < z + dz; k++) {
          if (!grid[i]?.[y - 1]?.[k]) return false;
        }
      }
      return true;
    }

    function placeBox(grid, x, y, z, dx, dy, dz, color) {
      for (let i = x; i < x + dx; i++) {
        for (let j = y; j < y + dy; j++) {
          for (let k = z; k < z + dz; k++) {
            grid[i][j][k] = color;
          }
        }
      }
    }

    function smartPlaceBoxes(boxes, grid, gridX, gridY, gridZ) {
      const placedBoxes = [];
      const maxHeightAtZ = Array(gridZ).fill(0).map((_, z) =>
        Math.floor(gridY - z * (gridY / gridZ)) // bentuk tangga
      );

      for (const box of boxes) {
        let placed = false;
        const orientations = [
          [box.dx, box.dy, box.dz],
          [box.dz, box.dy, box.dx],
          [box.dx, box.dz, box.dy],
        ];

        for (const [dx, dy, dz] of orientations) {
          for (let y = 0; y < gridY; y++) {
            for (let z = 0; z < gridZ; z++) {
              for (let x = 0; x < gridX; x++) {
                if (
                  x + dx <= gridX &&
                  y + dy <= gridY &&
                  z + dz <= gridZ &&
                  y + dy <= maxHeightAtZ[z] &&
                  isAreaEmpty(grid, x, y, z, dx, dy, dz) &&
                  isSupported(grid, x, y, z, dx, dy, dz)
                ) {
                  placeBox(grid, x, y, z, dx, dy, dz, box.color);
                  placedBoxes.push({ ...box, x, y, z, dx, dy, dz });
                  placed = true;
                  break;
                }
              }
              if (placed) break;
            }
            if (placed) break;
          }
          if (placed) break;
        }
      }
      return placedBoxes;
    }

    const placed = smartPlaceBoxes(boxes, grid, gridX, gridY, gridZ);

    // Tampilkan box
    for (const box of placed) {
      const geometry = new THREE.BoxGeometry(box.dx * boxSize, box.dy * boxSize, box.dz * boxSize);
      const material = new THREE.MeshStandardMaterial({ color: box.color });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(
        (box.x + box.dx / 2) * boxSize,
        (box.y + box.dy / 2) * boxSize,
        (box.z + box.dz / 2) * boxSize
      );
      scene.add(cube);
    }

    const animate = () => {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    };
    animate();
  </script>
</body>
</html>

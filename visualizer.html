<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer — Fast Stair A→C</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #sidebar { position: absolute; top: 0; left: 0; width: 280px; height: 100%; background: #f7f7f7;
      overflow-y: auto; border-right: 1px solid #ddd; padding: 12px; box-sizing: border-box; z-index: 10; }
    .containerBox { background: #fff; border: 1px solid #ddd; margin-bottom: 10px; padding: 10px; border-radius: 6px; }
    .itemEntry { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .itemEntry input[type="checkbox"] { transform: scale(1.15); }
    #reportContainer { position: absolute; bottom: 0; left: 280px; right: 0;
      background: rgba(255,255,255,0.96); font-family: monospace; font-size: 13px;
      max-height: 34%; overflow-y: auto; display: flex; flex-wrap: wrap; border-top: 2px solid #000; z-index: 5; }
    .reportBox { border: 1px solid #ddd; padding: 10px; margin: 6px; flex: 1 1 240px; background: #fcfcfc; white-space: pre-wrap; border-radius: 6px; }
  </style>
</head>
<body>
<div id="sidebar"><h3>Container List</h3><div id="containerList"></div></div>
<div id="reportContainer"></div>
<canvas id="threeCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
const containerSizeMap = {
  "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
  "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
  "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
};
const UNIT = 10, GAP = 2, MAX_INSTANCES_PER_BATCH = 50000;

let scene = new THREE.Scene(); scene.background = new THREE.Color(0xffffff);
let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 150000);
camera.position.set(8000, 5200, 9600);
let renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); renderer.setSize(window.innerWidth, window.innerHeight);

let controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
let light = new THREE.AmbientLight(0xffffff, 0.9); scene.add(light);
let dirLight = new THREE.DirectionalLight(0xffffff, 0.4); dirLight.position.set(1,2,1); scene.add(dirLight);

let mainGroup = new THREE.Group(); scene.add(mainGroup);
let data = [], containerOffsets = [], needsRender = true;
function requestRender(){ needsRender = true; }

const geomCache = new Map(), matCache = new Map();
function getBoxGeometry(l,h,w){
  const L = Math.max(1, l - 2*GAP), H = Math.max(1, h - 2*GAP), W = Math.max(1, w - 2*GAP);
  const key = `${L}x${H}x${W}`;
  if (!geomCache.has(key)) geomCache.set(key, new THREE.BoxGeometry(L,H,W));
  return geomCache.get(key);
}
function getMaterial(color){
  const key = color.toLowerCase();
  if (!matCache.has(key)) matCache.set(key, new THREE.MeshStandardMaterial({ color: new THREE.Color(key), roughness: 0.6, metalness: 0.0 }));
  return matCache.get(key);
}

function drawContainerWireframe(type, index, parent){
  const size = containerSizeMap[type];
  const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size.length, size.height, size.width));
  const wire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
  const zOffset = index === 0 ? 0 : containerOffsets[index-1] + containerSizeMap[data[index-1].type].width + 200;
  containerOffsets[index] = zOffset + size.width;
  wire.position.set(size.length/2, size.height/2, zOffset + size.width/2);
  parent.add(wire);
  return { zOffset, size };
}
function getRotations(dim){
  const { length:l, width:w, height:h } = dim;
  return [
    { l, w, h },
    { l: w, w: h, h: l },
    { l: h, w: l, h: w }
  ];
}

function smartPlaceBoxes(container, items, failedMap, addInstance){
  const { size, zOffset } = container;
  const gx = Math.floor(size.length / UNIT), gy = Math.floor(size.height / UNIT), gz = Math.floor(size.width / UNIT);
  const occ = new Uint8Array(gx * gy * gz), idx = (x,y,z) => (y*gz + z)*gx + x;
  const maxYAtX = new Int32Array(gx); for (let x=0; x<gx; x++) maxYAtX[x] = Math.max(1, Math.floor(gy - x*0.4));

  items.sort((a,b)=>{
    const areaA = Math.max(...getRotations(a.dimensions).map(r=>r.l*r.w));
    const areaB = Math.max(...getRotations(b.dimensions).map(r=>r.l*r.w));
    if (areaA !== areaB) return areaB - areaA;
    return (b.weight||1)-(a.weight||1);
  });

  function tryPlace(rot){
    const dx = Math.ceil(rot.l/UNIT), dy = Math.ceil(rot.h/UNIT), dz = Math.ceil(rot.w/UNIT);
    for (let y=0; y+dy<=gy; y++){
      for (let x=0; x+dx<=gx; x++){
        let capOK = true; for (let xi=x; xi<x+dx; xi++) if (y+dy > maxYAtX[xi]) capOK = false; if (!capOK) continue;
        for (let z=0; z+dz<=gz; z++){
          let free = true;
          for (let xi=x; xi<x+dx && free; xi++) for (let yi=y; yi<y+dy && free; yi++) for (let zi=z; zi<z+dz; zi++) if (occ[idx(xi,yi,zi)]) free = false;
          if (!free) continue;
          if (y>0){
            let supported = true;
            for (let xi=x; xi<x+dx && supported; xi++) for (let zi=z; zi<z+dz && supported; zi++) if (!occ[idx(xi,y-1,zi)]) supported = false;
            if (!supported) continue;
          }
          for (let xi=x; xi<x+dx; xi++) for (let yi=y; yi<y+dy; yi++) for (let zi=z; zi<z+dz; zi++) occ[idx(xi,yi,zi)] = 1;
          return { px: x*UNIT + rot.l/2, py: y*UNIT + rot.h/2, pz: zOffset + z*UNIT + rot.w/2 };
        }
      }
    }
    return null;
  }

  items.forEach(item=>{
    for (let q=0; q<item.qty; q++){
      let placed = null;
      for (const rot of getRotations(item.dimensions)){ placed = tryPlace(rot); if (placed){ addInstance(item, rot, placed); break; } }
      if (!placed) failedMap[item.key] = (failedMap[item.key]||0)+1;
    }
  });
}

function addInstanceFactory(){
  const dummy = new THREE.Object3D();
  return function(item, rot, placed){
    const color = item.color || '#'+(Math.random()*0xFFFFFF|0).toString(16).padStart(6,'0');
    const geom = getBoxGeometry(rot.l, rot.h, rot.w);
    const mat = getMaterial(color);
    let mesh = mainGroup.getObjectByName(`${rot.l}|${rot.h}|${rot.w}|${color}`);
    if (!mesh){
      mesh = new THREE.InstancedMesh(geom, mat, MAX_INSTANCES_PER_BATCH);
      mesh.name = `${rot.l}|${rot.h}|${rot.w}|${color}`;
      mesh.count = 0;
      mainGroup.add(mesh);
    }
    dummy.position.set(placed.px, placed.py, placed.pz); dummy.updateMatrix();
    mesh.setMatrixAt(mesh.count++, dummy.matrix);
    mesh.instanceMatrix.needsUpdate = true;
  }
}

function renderFromData(payload){
  clearScene(); mainGroup.clear(); containerOffsets = [];
  const edgesGroup = new THREE.Group(); mainGroup.add(edgesGroup);
  data = payload;

  payload.forEach((containerObj, cIndex) => {
    const cont = drawContainerWireframe(containerObj.type, cIndex, edgesGroup);
    const failedMap = {};
    const boxList = containerObj.items.map((i, idx) => ({ ...i, key: `${i.model} ${i.size}\" (C${cIndex+1}-L${idx+1})` }));
    const addInst = addInstanceFactory();
    smartPlaceBoxes(cont, boxList, failedMap, addInst);
  });
  requestRender();
}
function clearScene(){
  mainGroup.traverse(obj => {
    if (obj.geometry) obj.geometry.dispose();
    if (obj.material) { if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose()); else obj.material.dispose(); }
  });
  mainGroup.clear();
}

window.addEventListener('message', e=>{ if (e.data?.type==='RENDER_CONTAINER') renderFromData(e.data.payload); });

function animate(){
  requestAnimationFrame(animate);
  if (needsRender){ controls.update(); renderer.render(scene, camera); needsRender = false; }
}
animate();
window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); requestRender(); });
</script>
</body>
</html>

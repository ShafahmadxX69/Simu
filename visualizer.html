function smartPlaceBoxes(container, items, failedMap) {
  const unit = 10;
  const gridX = Math.floor(container.size.length / unit);
  const gridY = Math.floor(container.size.height / unit);
  const gridZ = Math.floor(container.size.width / unit);

  const grid = Array.from({ length: gridX }, () => Array.from({ length: gridY }, () => Array(gridZ).fill(false)));

  // Definisikan zona distribusi
  const zones = [
    { startX: 0, endX: Math.floor(gridX * 0.4), maxLayers: 30 },
    { startX: Math.floor(gridX * 0.4), endX: Math.floor(gridX * 0.7), maxLayers: 20 },
    { startX: Math.floor(gridX * 0.7), endX: Math.floor(gridX * 0.9), maxLayers: 10 },
    { startX: Math.floor(gridX * 0.9), endX: gridX, maxLayers: 5 }
  ];

  const sortedItems = [...items].sort((a, b) => b.dimensions.height - a.dimensions.height);

  sortedItems.forEach(item => {
    const { length, width, height } = item.dimensions;
    const dx = Math.ceil(length / unit);
    const dy = Math.ceil(height / unit);
    const dz = Math.ceil(width / unit);
    const color = new THREE.Color(item.color || '#' + Math.floor(Math.random()*16777215).toString(16));
    let failed = 0;

    for (let q = 0; q < item.qty; q++) {
      let placed = false;

      // Coba isi dari zona depan ke belakang
      for (const zone of zones) {
        for (let x = zone.startX; x <= zone.endX - dx; x++) {
          for (let y = 0; y <= Math.min(gridY - dy, zone.maxLayers * dy); y++) {
            for (let z = -Math.floor(gridZ/2); z <= Math.floor(gridZ/2) - dz; z++) {
              let space = true;
              for (let xi = 0; xi < dx && space; xi++)
                for (let yi = 0; yi < dy && space; yi++)
                  for (let zi = 0; zi < dz && space; zi++) {
                    const xg = x + xi;
                    const yg = y + yi;
                    const zg = z + zi + Math.floor(gridZ/2);
                    if (grid[xg][yg][zg]) space = false;
                  }

              if (space) {
                for (let xi = 0; xi < dx; xi++)
                  for (let yi = 0; yi < dy; yi++)
                    for (let zi = 0; zi < dz; zi++) {
                      const xg = x + xi;
                      const yg = y + yi;
                      const zg = z + zi + Math.floor(gridZ/2);
                      grid[xg][yg][zg] = true;
                    }

                const box = new THREE.Mesh(
                  new THREE.BoxGeometry(length, height, width),
                  new THREE.MeshStandardMaterial({ color })
                );
                box.position.set(
                  container.xOffset + x * unit + length/2,
                  y * unit + height/2,
                  z * unit + width/2
                );
                scene.add(box);

                placed = true;
                break;
              }
            }
            if (placed) break;
          }
          if (placed) break;
        }
        if (placed) break; // Berhasil di zona manapun
      }

      if (!placed) {
        const key = `${item.model} ${item.size}"`;
        failedMap[key] = (failedMap[key] || 0) + 1;
      }
    }
  });
}

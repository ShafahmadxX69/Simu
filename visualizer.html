<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer – External Dimensions</title>
  <style>
    :root {
      --panel-bg: #f7f7f8;
      --border: #d8d8de;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { display: block; }

    #sidebar {
      position: absolute; inset: 0 auto 0 0; width: 280px; background: var(--panel-bg);
      border-right: 1px solid var(--border); z-index: 10; box-sizing: border-box; padding: 12px;
      overflow-y: auto;
    }
    #sidebar h3 { margin: 0 0 8px; }
    .containerBox { background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 10px; margin-bottom: 10px; }
    .muted { color: #666; font-size: 12px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .tag { border: 1px solid var(--border); border-radius: 999px; padding: 2px 8px; font-size: 12px; background: #fff; }

    #reportContainer {
      position: absolute; left: 280px; right: 0; bottom: 0; background: rgba(255,255,255,0.96);
      border-top: 2px solid #000; z-index: 5; font-family: var(--mono); font-size: 12px;
      max-height: 35%; overflow: auto; display: flex; flex-wrap: wrap; gap: 8px; padding: 8px;
    }
    .reportBox { border: 1px solid var(--border); background: #fff; border-radius: 8px; padding: 10px; white-space: pre-wrap; flex: 1 1 280px; }

    #topbar {
      position: absolute; left: 280px; right: 0; top: 0; height: 46px; background: rgba(255,255,255,0.9);
      border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; padding: 0 10px; z-index: 8;
      backdrop-filter: blur(4px);
    }
    #topbar button, #topbar select {
      border: 1px solid var(--border); background: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 13px;
    }
    #topbar .spacer { flex: 1; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Container List</h3>
    <div id="containerList"></div>
  </div>
  <div id="topbar">
    <button id="btnRenderDummy" title="Render contoh payload">Render Dummy</button>
    <button id="btnClearCache" title="Hapus cache lokal">Clear Cache</button>
    <label class="muted">Unit mm</label>
    <div class="spacer"></div>
    <span class="muted">Tip: Kirim payload via <code>postMessage</code> { type: "RENDER_CONTAINER", payload }</span>
  </div>
  <div id="reportContainer"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ------------------ CONFIG ------------------
  const GAP = 2; // mm, celah visual kecil agar outline tidak saling tembus
  const containerSizeMap = {
    "20FT (GP)": { length: 6058, width: 2438, height: 2591 },
    "40FT (GP)": { length: 12192, width: 2438, height: 2591 },
    "40FT (HQ)": { length: 12192, width: 2438, height: 2896 }
  };

  // ------------------ THREE SETUP ------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
  camera.position.set(9000, 6000, 9000);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;

  const ambient = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  let boxMeshes = [], containerOffsets = [], data = [];

  // ------------------ UTIL ------------------
  function hashPayload(payload) {
    try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0, 160); }
    catch { return String(Date.now()); }
  }
  function clearScene() { mainGroup.clear(); boxMeshes = []; }

  function withOutline(mesh, color = 0x000000) {
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color }));
    mesh.add(line);
    return mesh;
  }

  function addBox(dim, pos, color, key) {
    const geometry = new THREE.BoxGeometry(dim.l - GAP, dim.h - GAP, dim.w - GAP);
    const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), transparent: false, opacity: 0.95 });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(pos[0], pos[1], pos[2]);
    box.userData.key = key;
    withOutline(box, 0x000000);
    mainGroup.add(box);
    boxMeshes.push(box);
  }

  function drawFromCache(boxDataArray, containers) {
    clearScene();
    containerOffsets = [];
    containers.forEach((c, i) => drawContainerWireframe(c.type, i));
    boxDataArray.forEach(d => addBox({ l: d.l, h: d.h, w: d.w }, d.position, d.color, d.key));
  }

  // ------------------ CORE RENDER ------------------
  function renderFromData(payload, { useCache = true } = {}) {
    const reportEl = document.getElementById('reportContainer');
       const listEl = document.getElementById('containerList');

    const hash = hashPayload(payload);
    const cacheKey = `cachedBoxes_${hash}`;

    if (useCache) {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const parsed = JSON.parse(cached);
        drawFromCache(parsed.boxes, parsed.containers);
        listEl.innerHTML = buildSidebar(payload);
        reportEl.innerHTML = buildReport(parsed.stats);
        return;
      }
    }

    clearScene(); reportEl.innerHTML = ''; listEl.innerHTML = '';
    data = payload; containerOffsets = [];

    const allBoxes = []; const globalStats = [];

    payload.forEach((containerObj, cIndex) => {
      const container = drawContainerWireframe(containerObj.type, cIndex);
      const failedMap = {};
      const boxList = containerObj.items.map((i, idx) => ({
        ...i,
        key: `${i.model} ${i.size}\" (C${cIndex+1}-L${idx+1})`
      }));

      const placed = shelfPackMixed(container, boxList, failedMap);
      allBoxes.push(...placed.drawn);

      globalStats.push({
        containerIndex: cIndex+1,
        type: containerObj.type,
        placed: placed.countPlaced,
        failed: placed.countFailed,
        failedMap
      });
    });

    localStorage.setItem(cacheKey, JSON.stringify({ boxes: allBoxes, containers: payload.map(p=>({type:p.type})) , stats: globalStats }));

    listEl.innerHTML = buildSidebar(payload);
    reportEl.innerHTML = buildReport(globalStats);
  }

  // ------------------ PACKING: MIXED-ORIENTATION SHELF ------------------
  // Per layer (Y), isi lebar (Z) dengan kombinasi 2 orientasi terbaik (bisa 3V+1H),
  // lalu isi sepanjang X sebanyak mungkin untuk tiap kolom.
  const GAPZ = GAP, GAPX = GAP, GAPY = GAP;

  function mixPack(container, items, failedMap) {
  const size = container.size;
  const drawn = [];
  let countPlaced = 0, countFailed = 0;
  const randomColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');

  items.sort((a, b) => {
    const va = a.dimensions.l * a.dimensions.w * a.dimensions.h;
    const vb = b.dimensions.l * b.dimensions.w * b.dimensions.h;
    return vb - va;
  });

  for (const item of items) {
    const qty = Math.max(1, Number(item.qty) || 1);
    const rotations = getAllRotations(item.dimensions);

    // Cari kombinasi orientasi terbaik untuk isi lebar container
    let bestCombo = null;
    let minLeftover = Infinity;

    // Coba semua kombinasi sampai max 4 box per row (biar cepat)
    function backtrack(combo, widthSum) {
      if (widthSum > size.width) return;
      if (widthSum > 0) {
        const leftover = size.width - widthSum;
        if (leftover < minLeftover) {
          minLeftover = leftover;
          bestCombo = combo.slice();
        }
      }
      if (combo.length >= 4) return; // batasi kombinasi
      for (const rot of rotations) {
        combo.push(rot);
        backtrack(combo, widthSum + rot.w);
        combo.pop();
      }
    }
    backtrack([], 0);

    if (!bestCombo) {
      failedMap[item.key] = (failedMap[item.key] || 0) + qty;
      countFailed += qty;
      continue;
    }

    // Tempatkan sesuai kombinasi di seluruh panjang container
    let y = 0;
    while (y + bestCombo[0].h <= size.height && qty > 0) {
      let x = 0;
      while (x < size.length && qty > 0) {
        let z = 0;
        for (const rot of bestCombo) {
          if (qty <= 0) break;
          if (x + rot.l <= size.length && z + rot.w <= size.width && y + rot.h <= size.height) {
            const color = item.color || randomColor();
            const pos = [
              container.xOffset + x + rot.l / 2,
              y + rot.h / 2,
              z + rot.w / 2
            ];
            addBox({ l: rot.l, h: rot.h, w: rot.w }, pos, color, item.key);
            drawn.push({ l: rot.l, h: rot.h, w: rot.w, color, position: pos, key: item.key });
            countPlaced++;
            qty--;
          }
          z += rot.w;
        }
        x += bestCombo[0].l; // geser panjang sesuai orientasi pertama
      }
      y += bestCombo[0].h; // naik layer
    }
  }

  return { drawn, countPlaced, countFailed };
}

  function pickBestItemForWidth(items, widthRemain, heightRemain) {
    let best = null, score = -1;
    for (const it of items) {
      if ((it.qty||0) <= 0) continue;
      const rots = getAllRotations(it.dimensions).filter(r => r.w + GAP <= widthRemain && r.h + GAP <= heightRemain);
      if (!rots.length) continue;
      const maxW = Math.max(...rots.map(r=>r.w));
      const s = maxW + Math.min(it.qty, 100) * 1e-3;
      if (s > score) { score = s; best = { item: it, rots }; }
    }
    return best;
  }

  function bestRowMixWidth(dim, widthAvail, heightAvail) {
    const rots = getAllRotations(dim).filter(r => r.h + GAP <= heightAvail && r.w + GAP <= widthAvail);
    if (!rots.length) return null;
    const cands = rots.slice(0, 4);
    let best = null;

    for (let i = 0; i < cands.length; i++) {
      for (let j = 0; j < cands.length; j++) {
        const A = cands[i], B = cands[j];
        const maxB = Math.floor(widthAvail / (B.w + GAP));
        for (let b = 0; b <= maxB; b++) {
          const usedW_B = b * (B.w + GAP);
          const remainForA = widthAvail - usedW_B;
          if (remainForA < 0) continue;
          const a = Math.floor(remainForA / (A.w + GAP));
          const usedW_A = a * (A.w + GAP);
          const used = usedW_A + usedW_B;
          const leftover = widthAvail - used;
          if (a + b <= 0) continue;

          const rowHeight = Math.max(A.h, B.h);
          if (rowHeight + GAP > heightAvail) continue;

          const score = used - leftover * 5 - rowHeight * 0.0001;
          if (!best || score > best.score) {
            const cols = [];
            for (let k=0; k<a; k++) cols.push({ rot: A });
            for (let k=0; k<b; k++) cols.push({ rot: B });
            best = { cols, rowHeight, score };
          }
        }
      }
    }
    return best;
  }

  function getAllRotations(dim) {
    const L = dim.length ?? dim.l, W = dim.width ?? dim.w, H = dim.height ?? dim.h;
    const uniq = new Set();
    const out = [];
    const perms = [
      { l:L, w:W, h:H }, { l:L, w:H, h:W },
      { l:W, w:L, h:H }, { l:W, w:H, h:L },
      { l:H, w:L, h:W }, { l:H, w:W, h:L }
    ];
    for (const p of perms) {
      const k = `${p.l}|${p.w}|${p.h}`;
      if (!uniq.has(k)) { uniq.add(k); out.push(p); }
    }
    // urutkan: tinggi kecil dulu (biar layer efisien), lalu footprint besar
    out.sort((a,b)=> (a.h-b.h) || ((b.l*b.w)-(a.l*a.w)) );
    return out;
  }

  // ------------------ CONTAINER WIREFRAME ------------------
  function drawContainerWireframe(type, index) {
    const size = containerSizeMap[type];
    if (!size) throw new Error(`Unknown container type: ${type}`);
    const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
    const xOffset = index === 0 ? 0 : containerOffsets[index-1] + containerSizeMap[data[index-1].type].length + 500;
    containerOffsets[index] = xOffset + size.length;
    line.position.set(xOffset + size.length/2, size.height/2, size.width/2);
    mainGroup.add(line);
    const gridHelper = new THREE.GridHelper(size.length, Math.max(2, Math.round(size.length/500)), 0x999999, 0xdddddd);
    gridHelper.rotation.x = Math.PI/2;
    gridHelper.position.set(xOffset + size.length/2, 1, size.width/2);
    mainGroup.add(gridHelper);
    return { xOffset, size };
  }

  // ------------------ UI BUILDERS ------------------
  function buildSidebar(payload) {
    let html = '';
    payload.forEach((c, i) => {
      const s = containerSizeMap[c.type];
      html += `
        <div class="containerBox">
          <div class="row"><strong>C${i+1}</strong> <span class="tag">${c.type}</span></div>
          <div class="muted">${s.length}×${s.width}×${s.height} mm</div>
          <div class="muted">Items: ${c.items.reduce((a,b)=>a+(b.qty||1),0)}</div>
        </div>
      `;
    });
    return html;
  }

  function buildReport(stats) {
    let html = '';
    stats.forEach(s => {
      html += `
        <div class="reportBox">
        C${s.containerIndex} [${s.type}]
        Placed: ${s.placed} | Failed: ${s.failed}
${Object.keys(s.failedMap).length ? '\nFailed detail:\n' + Object.entries(s.failedMap).map(([k,v])=>`- ${k}: ${v}`).join('\n') : ''}
        </div>
      `;
    });
    return html;
  }

  // ------------------ MESSAGE & DUMMY ------------------
  window.addEventListener('message', (event) => {
    if (event?.data?.type === 'RENDER_CONTAINER') {
      try { renderFromData(event.data.payload); }
      catch (e) { console.error(e); }
    }
  });

  document.getElementById('btnRenderDummy').addEventListener('click', () => renderDummy());
  document.getElementById('btnClearCache').addEventListener('click', () => { localStorage.clear(); alert('Cache cleared'); });

  function renderDummy() {
    // Ganti dimensi & qty dengan kasusmu (misal target 471 pcs).
    const dummyPayload = [
      {
        type: '40FT (HQ)',
        items: [
          { model: 'FQ803', size: 24, qty: 600, dimensions: { l: 600, w: 400, h: 300 }, color: '#F472B6' }
        ]
      }
    ];
    renderFromData(dummyPayload, { useCache: false });
  }

  window.addEventListener('DOMContentLoaded', () => {
    if (window.top === window.self) renderDummy();
  });

  // ------------------ RESIZE & ANIMATE ------------------
  function onResize() {
    const w = window.innerWidth; const h = window.innerHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer Pro (Instanced + Stair-Stack)</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #sidebar {
      position: absolute; top: 0; left: 0;
      background: #f7f7f7; width: 280px; height: 100%;
      overflow-y: auto; border-right: 1px solid #ddd;
      padding: 12px; box-sizing: border-box; z-index: 10;
    }
    .containerBox { background: #fff; border: 1px solid #e4e4e4; margin-bottom: 12px; padding: 10px; border-radius: 10px; }
    .itemEntry { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
    .itemEntry input[type="checkbox"] { transform: scale(1.15); }
    #reportContainer {
      position: absolute; bottom: 0; left: 280px; right: 0;
      background: rgba(255,255,255,0.96); font-family: monospace; font-size: 13px;
      max-height: 34%; overflow-y: auto; display: flex; flex-wrap: wrap; border-top: 2px solid #000; z-index: 5;
    }
    .reportBox { border: 1px solid #e4e4e4; padding: 10px; margin: 6px; flex: 1 1 240px; background: #fcfcfc; white-space: pre-wrap; border-radius: 10px; }
  </style>
</head>
<body>

<div id="sidebar">
  <h3>Container List</h3>
  <div id="containerList"></div>
</div>

<div id="reportContainer"></div>
<canvas id="threeCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
// ========================= CONFIG =========================
const containerSizeMap = {
  "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
  "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
  "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
};

const UNIT = 10;                 // grid unit size in mm
const MAX_INSTANCES_PER_MESH = 50000; // batch to avoid huge buffers

// =================== THREE.JS BOOTSTRAP ===================
let scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
camera.position.set(8000, 5000, 9000);
let renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);

let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.addEventListener('change', () => requestRender());

scene.add(new THREE.AmbientLight(0xffffff, 1));

let mainGroup = new THREE.Group();
scene.add(mainGroup);

let data = [];
let containerOffsets = [];
let needsRender = true;

function requestRender(){ needsRender = true; }

function clearScene(){
  mainGroup.traverse(obj => {
    if (obj.geometry) obj.geometry.dispose();
    if (obj.material) {
      if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
      else obj.material.dispose();
    }
  });
  mainGroup.clear();
}

// ========== MATERIAL with per-instance opacity (custom shader) ==========
function makeInstancedMaterial(baseColor){
  const mat = new THREE.MeshStandardMaterial({ color: baseColor, transparent: true, opacity: 1 });
  mat.onBeforeCompile = (shader) => {
    shader.vertexShader = shader.vertexShader.replace(
      '#include <common>',
      `#include <common>\nattribute float instanceAlpha;\nvarying float vAlpha;`
    ).replace(
      '#include <begin_vertex>',
      `#include <begin_vertex>\nvAlpha = instanceAlpha;`
    );
    shader.fragmentShader = shader.fragmentShader.replace(
      '#include <common>',
      `#include <common>\nvarying float vAlpha;`
    ).replace(
      'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
      'gl_FragColor = vec4( outgoingLight, diffuseColor.a * vAlpha );'
    );
    mat.userData.shader = shader;
  };
  return mat;
}

// cache: geometry per size, material per color
const geomCache = new Map(); // key: `${l}x${h}x${w}` => BoxGeometry
const matCache = new Map();  // key: color string => MeshStandardMaterial (customized)

function getBoxGeometry(l,h,w){
  const key = `${l}x${h}x${w}`;
  if (!geomCache.has(key)) geomCache.set(key, new THREE.BoxGeometry(l,h,w));
  return geomCache.get(key);
}
function getMaterial(color){
  const key = color.toLowerCase();
  if (!matCache.has(key)) matCache.set(key, makeInstancedMaterial(new THREE.Color(key)));
  return matCache.get(key);
}

// =================== WIREFRAME (one per container) ===================
function drawContainerWireframe(type, index, parent){
  const size = containerSizeMap[type];
  const geo = new THREE.BoxGeometry(size.length, size.height, size.width);
  const edges = new THREE.EdgesGeometry(geo);
  const wire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
  const zOffset = index === 0 ? 0 : containerOffsets[index-1] + containerSizeMap[data[index-1].type].width + 200; // lay containers side-by-side across Z
  containerOffsets[index] = zOffset + size.width;
  wire.position.set(size.length/2, size.height/2, zOffset + size.width/2);
  parent.add(wire);
  return { zOffset, size };
}

// =================== ROTATIONS ===================
function getRotations(dim){
  const { length:l, width:w, height:h } = dim;
  return [
    { l, w, h },
    { l: w, w: h, h: l },
    { l: h, w: l, h: w }
  ];
}

// =================== PACKING (stair-stack, stable) ===================
// Heuristic goals: big-first, heavy-bottom, no-floating, front->back stair profile (Z+ lower)
function smartPlaceBoxes(container, items, failedMap, addInstances){
  const { size, zOffset } = container;
  const gx = Math.floor(size.length / UNIT);
  const gy = Math.floor(size.height / UNIT);
  const gz = Math.floor(size.width  / UNIT);

  // Occupancy grid (flattened). store 0/1 (empty/filled) for support tests.
  const occ = new Uint8Array(gx * gy * gz);
  const idx = (x,y,z) => (y*gz + z)*gx + x;

  // Stair profile along Z (front to back): max usable height per Z column.
  const maxYAtZ = new Int32Array(gz);
  const step = 0.4; // cells per X step -> gentle slope
  for (let z=0; z<gz; z++) {
    const h = Math.max(1, Math.floor(gy - z * step));
    maxYAtZ[z] = h;
  }

  // Sort: large base area first, then volume, then weight
  items.sort((a,b)=>{
    const bestA = getRotations(a.dimensions).reduce((m,r)=>Math.max(m, r.l*r.w), 0);
    const bestB = getRotations(b.dimensions).reduce((m,r)=>Math.max(m, r.l*r.w), 0);
    if (bestA !== bestB) return bestB - bestA;
    const volA = a.dimensions.l*a.dimensions.w*a.dimensions.h;
    const volB = b.dimensions.l*b.dimensions.w*b.dimensions.h;
    if (volA !== volB) return volB - volA;
    return (b.weight||1)-(a.weight||1);
  });

  // Scan order: y from 0.., z from 0.. (front->back), x from 0..
  const tryPlace = (rot) => {
    const dx = Math.ceil(rot.l/UNIT), dy = Math.ceil(rot.h/UNIT), dz = Math.ceil(rot.w/UNIT);
    for (let y=0; y+dy<=gy; y++){
      for (let z=0; z+dz<=gz; z++){
        if (y+dy > maxYAtZ[z]) continue; // respect stair cap at front column
        for (let x=0; x+dx<=gx; x++){
          // quick reject: space free?
          let free = true;
          for (let xi=x; xi<x+dx && free; xi++){
            for (let yi=y; yi<y+dy && free; yi++){
              for (let zi=z; zi<z+dz && free; zi++){
                if (occ[idx(xi,yi,zi)]) free = false;
              }
            }
          }
          if (!free) continue;
          // support check: if y>0, all cells below footprint at y-1 must be filled
          if (y>0){
            let supported = true;
            const baseY = y-1;
            const ref = occ[idx(x, baseY, z)];
            for (let xi=x; xi<x+dx && supported; xi++){
              for (let zi=z; zi<z+dz && supported; zi++){
                if (!occ[idx(xi, baseY, zi)]) supported = false;
              }
            }
            if (!supported) continue;
          }
          // place
          for (let xi=x; xi<x+dx; xi++){
            for (let yi=y; yi<y+dy; yi++){
              for (let zi=z; zi<z+dz; zi++){
                occ[idx(xi,yi,zi)] = 1;
              }
            }
          }
          // world coords
          const px = x*UNIT + rot.l/2;
          const py = y*UNIT + rot.h/2;
          const pz = zOffset + z*UNIT + rot.w/2;
          return { px,py,pz, dx,dy,dz };
        }
      }
    }
    return null;
  };

  items.forEach(item => {
    for (let q=0; q<item.qty; q++){
      const rotations = getRotations(item.dimensions);
      // prefer orientation that gives larger base (l*w), then lower height
      rotations.sort((a,b)=> (b.l*b.w - a.l*a.w) || (a.h - b.h));
      let placed = null;
      for (const rot of rotations){
        placed = tryPlace(rot);
        if (placed){
          addInstances(item, rot, placed);
          break;
        }
      }
      if (!placed){
        failedMap[item.key] = (failedMap[item.key]||0)+1;
      }
    }
  });
}

// =================== INSTANCING LAYER ===================
// We group by (color, l,h,w) => InstancedMesh batches (with per-instance alpha)
function InstanceBucket(l,h,w,color){
  this.key = `${l}x${h}x${w}|${color}`;
  this.geometry = getBoxGeometry(l,h,w);
  this.material = getMaterial(color);
  this.meshes = []; // array of InstancedMesh (batched)
  this.counts = []; // current count per mesh
}
InstanceBucket.prototype._ensureMesh = function(index){
  while (this.meshes.length <= index){
    const mesh = new THREE.InstancedMesh(this.geometry, this.material, MAX_INSTANCES_PER_MESH);
    // allocate per-instance alpha attribute (default 1)
    const alphas = new Float32Array(MAX_INSTANCES_PER_MESH).fill(1);
    mesh.instanceAlpha = alphas; // keep reference
    mesh.geometry.setAttribute('instanceAlpha', new THREE.InstancedBufferAttribute(alphas, 1));
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    mainGroup.add(mesh);
    this.meshes.push(mesh);
    this.counts.push(0);
  }
};
InstanceBucket.prototype.add = function(matrix, alpha){
  const last = this.meshes.length-1;
  const needNew = last<0 || this.counts[last] >= MAX_INSTANCES_PER_MESH;
  if (needNew) this._ensureMesh(this.meshes.length);
  const i = this.meshes.length-1;
  const idx = this.counts[i]++;
  this.meshes[i].setMatrixAt(idx, matrix);
  this.meshes[i].instanceAlpha[idx] = alpha==null?1:alpha;
  this.meshes[i].geometry.attributes.instanceAlpha.needsUpdate = true;
  this.meshes[i].count = this.counts[i];
};
InstanceBucket.prototype.setSelected = function(predicate){
  // Darken non-selected by alpha 0.1
  this.meshes.forEach(mesh => {
    for (let i=0; i<this.counts[this.meshes.indexOf(mesh)]; i++){
      const ok = predicate(i, mesh);
      mesh.instanceAlpha[i] = ok ? 1 : 0.1;
    }
    mesh.geometry.attributes.instanceAlpha.needsUpdate = true;
  });
};

// Manager: one bucket per (color & size)
const buckets = new Map();
function getBucket(l,h,w,color){
  const key = `${l}|${h}|${w}|${color}`;
  if (!buckets.has(key)) buckets.set(key, new InstanceBucket(l,h,w,color));
  return buckets.get(key);
}

// Mapping instance -> item key for filtering
const instanceKeyRefs = []; // entries: { bucketKey, meshIndex, instanceIndex, itemKey }

function addInstancesFactory(){
  const dummy = new THREE.Object3D();
  return function(item, rot, placed){
    const bucket = getBucket(rot.l, rot.h, rot.w, (item.color || '#'+(Math.random()*0xFFFFFF|0).toString(16).padStart(6,'0')));
    dummy.position.set(placed.px, placed.py, placed.pz);
    dummy.rotation.set(0,0,0);
    dummy.updateMatrix();

    const beforeMeshes = bucket.meshes.length;
    const beforeCount  = beforeMeshes? bucket.counts[beforeMeshes-1] : 0;
    bucket.add(dummy.matrix, 1);
    const afterMeshes = bucket.meshes.length;
    const meshIndex   = afterMeshes-1;
    const instanceIdx = (afterMeshes===beforeMeshes) ? beforeCount : 0;

    instanceKeyRefs.push({ bucketKey: `${rot.l}|${rot.h}|${rot.w}|${(item.color||'')}` , meshIndex, instanceIndex: instanceIdx, itemKey: item.key });
  }
}

// =================== UI & RENDER ===================
let boxKeySet = new Set();

function renderFromData(payload){
  clearScene();
  buckets.clear();
  instanceKeyRefs.length = 0;
  document.getElementById('reportContainer').innerHTML = '';
  const containerDOM = document.getElementById('containerList');
  containerDOM.innerHTML = '';
  data = payload; containerOffsets = [];

  const edgesGroup = new THREE.Group();
  mainGroup.add(edgesGroup);

  payload.forEach((containerObj, cIndex) => {
    const cont = drawContainerWireframe(containerObj.type, cIndex, edgesGroup);
    const failedMap = {};

    const boxList = containerObj.items.map((i, idx) => {
      const key = `${i.model} ${i.size}\" (C${cIndex + 1}-L${idx + 1})`;
      return { ...i, key };
    });

    // collect keys for sidebar
    boxList.forEach(it=> boxKeySet.add(it.key));

    const addInst = addInstancesFactory();
    smartPlaceBoxes(cont, boxList, failedMap, addInst);

    // Sidebar UI per container
    const box = document.createElement('div');
    box.className = 'containerBox';
    box.innerHTML = `<strong>Container ${cIndex + 1} — ${containerObj.type}</strong><br>`;
    boxList.forEach(item => {
      const entry = document.createElement('div'); entry.className = 'itemEntry';
      const cb = document.createElement('input'); cb.type = 'checkbox'; cb.value = item.key;
      cb.addEventListener('change', applyFilterFromSidebar);
      const label = document.createElement('label'); label.textContent = item.key;
      entry.appendChild(cb); entry.appendChild(label); box.appendChild(entry);
    });
    containerDOM.appendChild(box);

    // Report
    let reportText = `Container ${cIndex + 1}: ${containerObj.type}\n`;
    reportText += Object.keys(failedMap).length
      ? Object.entries(failedMap).map(([k,v]) => `❌ ${k} tidak muat ${v} pcs`).join('\n')
      : '✅ Semua box berhasil dimuat\n';
    const reportBox = document.createElement('div'); reportBox.className = 'reportBox'; reportBox.innerText = reportText;
    document.getElementById('reportContainer').appendChild(reportBox);
  });

  requestRender();
}

function applyFilterFromSidebar(){
  const active = new Set(Array.from(document.querySelectorAll('.itemEntry input:checked')).map(cb=>cb.value));
  const lighten = active.size>0;

  // per-instance alpha via instance attribute
  instanceKeyRefs.forEach(ref => {
    const bucket = buckets.get(ref.bucketKey);
    if (!bucket) return;
    const mesh = bucket.meshes[ref.meshIndex];
    const show = !lighten || active.has(ref.itemKey);
    mesh.instanceAlpha[ref.instanceIndex] = show ? 1 : 0.1;
    mesh.geometry.attributes.instanceAlpha.needsUpdate = true;
  });

  requestRender();
}

window.addEventListener('message', (event) => {
  if (event.data?.type === 'RENDER_CONTAINER') renderFromData(event.data.payload);
});

function animate(){
  requestAnimationFrame(animate);
  if (needsRender){
    controls.update();
    renderer.render(scene, camera);
    needsRender = false;
  }
}
animate();

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  requestRender();
});

</script>
</body>
</html>

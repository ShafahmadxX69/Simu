<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer – Mixed-Orientation Shelf Packing</title>
  <style>
    :root {
      --panel-bg: #f7f7f8;
      --border: #d8d8de;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { display: block; }

    #sidebar {
      position: absolute; inset: 0 auto 0 0; width: 280px; background: var(--panel-bg);
      border-right: 1px solid var(--border); z-index: 10; box-sizing: border-box; padding: 12px;
      overflow-y: auto;
    }
    #sidebar h3 { margin: 0 0 8px; }
    .containerBox { background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 10px; margin-bottom: 10px; }
    .muted { color: #666; font-size: 12px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .tag { border: 1px solid var(--border); border-radius: 999px; padding: 2px 8px; font-size: 12px; background: #fff; }

    #reportContainer {
      position: absolute; left: 280px; right: 0; bottom: 0; background: rgba(255,255,255,0.96);
      border-top: 2px solid #000; z-index: 5; font-family: var(--mono); font-size: 12px;
      max-height: 35%; overflow: auto; display: flex; flex-wrap: wrap; gap: 8px; padding: 8px;
    }
    .reportBox { border: 1px solid var(--border); background: #fff; border-radius: 8px; padding: 10px; white-space: pre-wrap; flex: 1 1 280px; }

    #topbar {
      position: absolute; left: 280px; right: 0; top: 0; height: 46px; background: rgba(255,255,255,0.9);
      border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; padding: 0 10px; z-index: 8;
      backdrop-filter: blur(4px);
    }
    #topbar button, #topbar select {
      border: 1px solid var(--border); background: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 13px;
    }
    #topbar .spacer { flex: 1; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Container List</h3>
    <div id="containerList"></div>
  </div>
  <div id="topbar">
    <button id="btnRenderDummy" title="Render contoh payload">Render Dummy</button>
    <button id="btnClearCache" title="Hapus cache lokal">Clear Cache</button>
    <label class="muted">Unit mm</label>
    <div class="spacer"></div>
    <span class="muted">Tip: Kirim payload via <code>postMessage</code> { type: "RENDER_CONTAINER", payload }</span>
  </div>
  <div id="reportContainer"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ------------------ CONFIG ------------------
  const GAP = 2; // mm, celah visual minimal agar tidak tembus outline
  const containerSizeMap = {
    "20FT (GP)": { length: 6058, width: 2438, height: 2591 },
    "40FT (GP)": { length: 12192, width: 2438, height: 2591 },
    "40FT (HQ)": { length: 12192, width: 2438, height: 2896 }
  };

  // ------------------ THREE SETUP ------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
  camera.position.set(9000, 6000, 9000);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;

  const ambient = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  let boxMeshes = [], containerOffsets = [], data = [];

  // ------------------ UTIL ------------------
  function hashPayload(payload) {
    try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0, 160); }
    catch { return String(Date.now()); }
  }
  function clearScene() { mainGroup.clear(); boxMeshes = []; }

  function withOutline(mesh, color = 0x000000) {
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color }));
    mesh.add(line);
    return mesh;
  }

  function addBox(dim, pos, color, key) {
    const geometry = new THREE.BoxGeometry(dim.l - GAP, dim.h - GAP, dim.w - GAP);
    const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), transparent: false, opacity: 0.95 });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(pos[0], pos[1], pos[2]);
    box.userData.key = key;
    withOutline(box, 0x000000);
    mainGroup.add(box);
    boxMeshes.push(box);
  }

  function drawFromCache(boxDataArray, containers) {
    clearScene();
    containerOffsets = [];
    containers.forEach((c, i) => drawContainerWireframe(c.type, i));
    boxDataArray.forEach(d => addBox({ l: d.l, h: d.h, w: d.w }, d.position, d.color, d.key));
  }

  // ------------------ CORE RENDER ------------------
  function renderFromData(payload, { useCache = true } = {}) {
    const reportEl = document.getElementById('reportContainer');
    const listEl = document.getElementById('containerList');

    const hash = hashPayload(payload);
    const cacheKey = `cachedBoxes_${hash}`;

    if (useCache) {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const parsed = JSON.parse(cached);
        drawFromCache(parsed.boxes, parsed.containers);
        listEl.innerHTML = buildSidebar(payload);
        reportEl.innerHTML = buildReport(parsed.stats);
        return;
      }
    }

    clearScene(); reportEl.innerHTML = ''; listEl.innerHTML = '';
    data = payload; containerOffsets = [];

    const allBoxes = []; const globalStats = [];

    payload.forEach((containerObj, cIndex) => {
      const container = drawContainerWireframe(containerObj.type, cIndex);
      const failedMap = {};
      const boxList = containerObj.items.map((i, idx) => ({
        ...i,
        key: `${i.model} ${i.size}\" (C${cIndex+1}-L${idx+1})`
      }));

      const placed = shelfPackMixed(container, boxList, failedMap);
      allBoxes.push(...placed.drawn);

      globalStats.push({
        containerIndex: cIndex+1,
        type: containerObj.type,
        placed: placed.countPlaced,
        failed: placed.countFailed,
        failedMap
      });
    });

    localStorage.setItem(cacheKey, JSON.stringify({ boxes: allBoxes, containers: payload.map(p=>({type:p.type})) , stats: globalStats }));

    listEl.innerHTML = buildSidebar(payload);
    reportEl.innerHTML = buildReport(globalStats);
  }

  // ------------------ PACKING: MIXED-ORIENTATION SHELF ------------------
  // Ide: per layer (tinggi Y), buat "shelfHeight" lalu isi lebar (Z) dengan kombinasi 2 orientasi terbaik
  // supaya sisa lebar minimal. Untuk tiap kolom Z, isi sepanjang X sebanyak mungkin.
  function shelfPackMixed(container, items, failedMap) {
  const size = container.size;
  const drawn = [];
  let countPlaced = 0, countFailed = 0;
  const randomColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');

  // Urutkan item dari volume terbesar
  items.sort((a, b) => {
    const va = a.dimensions.l * a.dimensions.w * a.dimensions.h;
    const vb = b.dimensions.l * b.dimensions.w * b.dimensions.h;
    return vb - va;
  });

  let y = 0;
  while (true) {
    const remain = items.reduce((s,i)=>s+(+i.qty||0),0);
    if (!remain) break;

    // Cari tinggi minimum yang bisa dipakai di layer ini
    let minH = Infinity;
    items.forEach(it=>{
      if ((it.qty||0) <= 0) return;
      getAllRotations(it.dimensions).forEach(r=>{
        if (r.h + GAP <= size.height - y) minH = Math.min(minH, r.h);
      });
    });
    if (!isFinite(minH)) break;

    let shelfTopY = y;
    let z = 0;
    let progressInWidth = false;

    while (z < size.width - GAP) {
      let candidate = pickBestItemForWidth(items, size.width - z, size.height - y);
      if (!candidate) break; // Tidak ada item yang muat di lebar tersisa

      const mix = bestRowMixWidth(candidate.item.dimensions, size.width - z, size.height - y);
      if (!mix || mix.cols.length === 0) {
        // Coba kandidat lain
        candidate.item.qty = 0; 
        continue;
      }

      const rowHeight = mix.rowHeight;
      const shelfHeight = Math.max(minH, rowHeight);
      if (y + shelfHeight > size.height) break;

      for (const col of mix.cols) {
        if (candidate.item.qty <= 0) {
          candidate = pickBestItemForWidth(items, size.width - z, size.height - y);
          if (!candidate) break;
        }
        const rot = col.rot;
        const colWidth = rot.w + GAP;
        let countAlongX = Math.floor((size.length + GAP) / (rot.l + GAP));
        if (countAlongX < 1) countAlongX = 1; // pastikan minimal 1

        const placeCount = Math.min(countAlongX, candidate.item.qty);
        if (placeCount <= 0) continue;

        for (let i = 0; i < placeCount; i++) {
          const x = (rot.l + GAP) * i;
          const pos = [
            container.xOffset + (rot.l/2) + x,
            y + (rot.h/2),
            z + (rot.w/2)
          ];
          const color = candidate.item.color || randomColor();
          addBox({ l: rot.l, h: rot.h, w: rot.w }, pos, color, candidate.item.key);
          drawn.push({ l: rot.l, h: rot.h, w: rot.w, color, position: pos, key: candidate.item.key });
          countPlaced++;
        }
        candidate.item.qty -= placeCount;
        z += colWidth;
        progressInWidth = true;
        if (z > size.width - GAP) break;
      }
      shelfTopY = Math.max(shelfTopY, y + shelfHeight);
    }

    if (!progressInWidth) break;
    y = shelfTopY;
    if (y > size.height - GAP) break;
  }

  // Hitung yang gagal
  items.forEach(it=>{
    const left = (+it.qty||0);
    if (left > 0) {
      failedMap[it.key] = (failedMap[it.key]||0) + left;
      countFailed += left;
    }
  });

  return { drawn, countPlaced, countFailed };
}

  // Pilih item yang paling cocok untuk sisa lebar + tinggi (qty>0)
  function pickBestItemForWidth(items, widthRemain, heightRemain) {
    let best = null, bestScore = -1;
    for (const it of items) {
      if ((it.qty||0) <= 0) continue;
      const rots = getAllRotations(it.dimensions).filter(r => r.w + GAP <= widthRemain && r.h + GAP <= heightRemain);
      if (!rots.length) continue;
      // skor: lebar terpakai maksimum * prioritas qty
      const maxW = Math.max(...rots.map(r=>r.w));
      const score = maxW + Math.min(it.qty, 100) * 1e-3;
      if (score > bestScore) { bestScore = score; best = { item: it, rots }; }
    }
    return best;
  }

  // Cari kombinasi 2 orientasi (boleh sama) untuk mengisi lebar (Z) dengan sisa minimal
  // Keluaran: { cols: [ { rot }, ... ], rowHeight }
  function bestRowMixWidth(dim, widthAvail, heightAvail) {
    const rots = getAllRotations(dim).filter(r => r.h + GAP <= heightAvail && r.w + GAP <= widthAvail);
    if (!rots.length) return null;

    // pilih 4 kandidat berdasarkan (tinggi naik, lalu w besar) biar masih realistis ke “3 vertikal + 1 horizontal”
    const cands = rots.slice(0, 4);

    let best = null;

    for (let i = 0; i < cands.length; i++) {
      for (let j = 0; j < cands.length; j++) {
        const A = cands[i], B = cands[j];
        // brute-force kecil: jumlah kolom B 0..max, sisanya A
        const maxB = Math.floor(widthAvail / (B.w + GAP));
        for (let b = 0; b <= maxB; b++) {
          const usedW_B = b * (B.w + GAP);
          const remainForA = widthAvail - usedW_B;
          if (remainForA < 0) continue;
          const a = Math.floor(remainForA / (A.w + GAP));
          const usedW_A = a * (A.w + GAP);
          const used = usedW_A + usedW_B;
          const leftover = widthAvail - used;

          if (a + b <= 0) continue;

          const rowHeight = Math.max(A.h, B.h);
          if (rowHeight + GAP > heightAvail) continue;

          const score = used - leftover * 5 - rowHeight * 0.0001; // prioritaskan lebar terpakai; penalti leftover
          if (!best || score > best.score) {
            const cols = [];
            for (let k=0; k<a; k++) cols.push({ rot: A });
            for (let k=0; k<b; k++) cols.push({ rot: B });
            best = { cols, rowHeight, score };
          }
        }
      }
    }
    return best;
  }

  function getAllRotations(dim) {
    const L = dim.length ?? dim.l, W = dim.width ?? dim.w, H = dim.height ?? dim.h;
    const uniq = new Set();
    const out = [];
    const perms = [
      { l:L, w:W, h:H }, { l:L, w:H, h:W },
      { l:W, w:L, h:H }, { l:W, w:H, h:L },
      { l:H, w:L, h:W }, { l:H, w:W, h:L }
    ];
    for (const p of perms) {
      const k = `${p.l}|${p.w}|${p.h}`;
      if (!uniq.has(k)) { uniq.add(k); out.push(p); }
    }
    // urutkan orientasi: tinggi dulu (kecil ke besar), lalu footprint (besar ke kecil)
    out.sort((a,b)=> (a.h-b.h) || ((b.l*b.w)-(a.l*a.w)) );
    return out;
  }

  // ------------------ CONTAINER WIREFRAME ------------------
  function drawContainerWireframe(type, index) {
    const size = containerSizeMap[type];
    if (!size) throw new Error(`Unknown container type: ${type}`);

    const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));

    const xOffset = index === 0 ? 0 : containerOffsets[index-1] + containerSizeMap[data[index-1].type].length + 500;
    containerOffsets[index] = xOffset + size.length;

    line.position.set(xOffset + size.length/2, size.height/2, size.width/2);
    mainGroup.add(line);

    const gridHelper = new THREE.GridHelper(size.length, Math.max(2, Math.round(size.length/500)), 0x999999, 0xdddddd);
    gridHelper.rotation.x = Math.PI/2;
    gridHelper.position.set(xOffset + size.length/2, 1, size.width/2);
    mainGroup.add(gridHelper);

    return { xOffset, size };
  }

  // ------------------ UI BUILDERS ------------------
  function buildSidebar(payload) {
    let html = '';
    payload.forEach((c, i) => {
      const s = containerSizeMap[c.type];
      html += `
        <div class="containerBox">
          <div class="row"><strong>C${i+1}</strong> <span class="tag">${c.type}</span></div>
          <div class="muted">${s.length}×${s.width}×${s.height} mm</div>
          <div class="muted">Items: ${c.items.reduce((a,b)=>a+(b.qty||1),0)}</div>
        </div>
      `;
    });
    return html;
  }

  function buildReport(stats) {
    let html = '';
    stats.forEach(s => {
      html += `
        <div class="reportBox">
        C${s.containerIndex} [${s.type}]
        Placed: ${s.placed} | Failed: ${s.failed}
${Object.keys(s.failedMap).length ? '\nFailed detail:\n' + Object.entries(s.failedMap).map(([k,v])=>`- ${k}: ${v}`).join('\n') : ''}
        </div>
      `;
    });
    return html;
  }

  // ------------------ MESSAGE & DUMMY ------------------
  window.addEventListener('message', (event) => {
    if (event?.data?.type === 'RENDER_CONTAINER') {
      try { renderFromData(event.data.payload); }
      catch (e) { console.error(e); }
    }
  });

  document.getElementById('btnRenderDummy').addEventListener('click', () => renderDummy());
  document.getElementById('btnClearCache').addEventListener('click', () => { localStorage.clear(); alert('Cache cleared'); });

  function renderDummy() {
    // contoh 1 tipe box (kasus umum 471 pcs) + variasi lain
    const dummyPayload = [
      {
        type: '40FT (HQ)',
        items: [
          // ganti dimensi ini sesuai actual box kamu untuk melihat mix 3V + 1H otomatis
          { model: 'FQ803', size: 24, qty: 600, dimensions: { l: 600, w: 400, h: 300 }, color: '#F472B6' },
          { model: 'Tambahan', size: 22, qty: 40, dimensions: { l: 500, w: 500, h: 300 }, color: '#60A5FA' }
        ]
      }
    ];
    renderFromData(dummyPayload, { useCache: false });
  }

  window.addEventListener('DOMContentLoaded', () => {
    if (window.top === window.self) renderDummy();
  });

  // ------------------ RESIZE & ANIMATE ------------------
  function onResize() {
    const w = window.innerWidth; const h = window.innerHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
  </script>
</body>
</html>

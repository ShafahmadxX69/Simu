<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer Cached</title>
  <title>Visualizer Cached Full</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #sidebar {
      position: absolute; top: 0; left: 0;
      background: #f0f0f0;
      width: 260px; height: 100%;
      background: #f0f0f0; width: 260px; height: 100%;
      overflow-y: auto; border-right: 1px solid #ccc;
      padding: 10px; box-sizing: border-box; z-index: 10;
    }
    .containerBox {
      background: white; border: 1px solid #ccc;
      margin-bottom: 10px; padding: 10px;
    }
    .itemEntry {
      display: flex; align-items: center;
      gap: 4px; margin: 6px 0;
    }
    .itemEntry input[type="checkbox"] {
      transform: scale(1.2); margin-right: 6px;
    }
    #reportContainer {
      position: absolute;
      bottom: 0; left: 260px; right: 0;
      position: absolute; bottom: 0; left: 260px; right: 0;
      background: rgba(255,255,255,0.95);
      font-family: monospace;
      font-size: 13px; max-height: 35%;
      overflow-y: auto;
      font-family: monospace; font-size: 13px;
      max-height: 35%; overflow-y: auto;
      display: flex; flex-wrap: wrap;
      border-top: 2px solid #000;
      z-index: 5;
      border-top: 2px solid #000; z-index: 5;
    }
    .reportBox {
      border: 1px solid #ccc; padding: 10px; margin: 5px;
      flex: 1 1 220px; background: #fdfdfd; white-space: pre-wrap;
    }
  </style>
</head>
<body>
<div id="sidebar"><h3>Container List</h3><div id="containerList"></div></div>
<div id="reportContainer"></div>
<canvas id="threeCanvas"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
const containerSizeMap = {
  "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
  "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
  "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
};

let scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 50000);
camera.position.set(8000, 5000, 8000);
let renderer = new THREE.WebGLRenderer({ canvas: document.querySelector("#threeCanvas"), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
let controls = new THREE.OrbitControls(camera, renderer.domElement);
let light = new THREE.AmbientLight(0xffffff, 1);
scene.add(light);

let mainGroup = new THREE.Group();
scene.add(mainGroup);
let boxMeshes = [], containerOffsets = [], data = [];

function hashPayload(payload) {
  return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0, 100);
}
function clearScene() {
  mainGroup.clear(); boxMeshes = [];
}
function drawFromCache(boxDataArray) {
  clearScene();
  boxDataArray.forEach(data => {
    const geometry = new THREE.BoxGeometry(data.l, data.h, data.w);
    const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(data.color), transparent: true, opacity: 1 });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(...data.position);
    mainGroup.add(box);
    boxMeshes.push(box);
  });
}
function renderFromData(payload) {
  const hash = hashPayload(payload);
  const cacheKey = `cachedBoxes_${hash}`;
  const cached = localStorage.getItem(cacheKey);
  if (cached) return drawFromCache(JSON.parse(cached));
  clearScene(); document.getElementById("reportContainer").innerHTML = "";
  document.getElementById("containerList").innerHTML = "";
  data = payload; containerOffsets = [];
  let allBoxes = [];
  payload.forEach((containerObj, cIndex) => {
    const container = drawContainerWireframe(containerObj.type, cIndex);
    const failedMap = {};
    const boxList = containerObj.items.map((i, idx) => {
      const key = `${i.model} ${i.size}" (C${cIndex + 1}-L${idx + 1})`;
      return { ...i, key };
    });
    allBoxes.push(...smartPlaceBoxes(container, boxList, failedMap));
  });
  localStorage.setItem(cacheKey, JSON.stringify(allBoxes));
}
function getRotations(dim) {
  const { length, width, height } = dim;
  return [
    { l: length, w: width, h: height },
    { l: width, w: height, h: length },
    { l: height, w: length, h: width }
  ];
}
function smartPlaceBoxes(container, items, failedMap) {
  const unit = 10;
  const gridX = Math.floor(container.size.length / unit);
  const gridY = Math.floor(container.size.height / unit);
  const gridZ = Math.floor(container.size.width / unit);
  const grid = Array.from({ length: gridX }, () => Array.from({ length: gridY }, () => Array(gridZ).fill(null)));
  let idCounter = 1, result = [];
  let idCounter = 1, boxCache = [];
  items.sort((a, b) => {
    const volA = a.dimensions.l * a.dimensions.h * a.dimensions.w;
    const volB = b.dimensions.l * b.dimensions.h * b.dimensions.w;
    return volB - volA;
  });
  items.forEach(item => {
    for (let q = 0; q < item.qty; q++) {
      const rot = { l: item.dimensions.l, h: item.dimensions.h, w: item.dimensions.w };
      let x = 0, y = 0, z = 0; // Simplified for demo
      for (let xi = x; xi < x+1; xi++)
        for (let yi = y; yi < y+1; yi++)
          for (let zi = z; zi < z+1; zi++)
            grid[xi][yi][zi] = idCounter;
      let placed = false;
      const color = item.color || '#'+Math.floor(Math.random()*16777215).toString(16);
      const pos = [x*unit + rot.l/2, y*unit + rot.h/2, container.xOffset + z*unit + rot.w/2];
      const geometry = new THREE.BoxGeometry(rot.l, rot.h, rot.w);
      const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), transparent: true, opacity: 1 });
      const box = new THREE.Mesh(geometry, material);
      box.position.set(...pos);
      box.userData.key = item.key;
      mainGroup.add(box);
      boxMeshes.push(box);
      result.push({ l: rot.l, h: rot.h, w: rot.w, color, position: pos, key: item.key });
      idCounter++;
      outer: for (let y = 0; y < gridY; y++) {
        for (let x = 0; x < gridX; x++) {
          for (let z = 0; z < gridZ; z++) {
            for (let rot of getRotations(item.dimensions)) {
              const dx = Math.ceil(rot.l / unit),
                    dy = Math.ceil(rot.h / unit),
                    dz = Math.ceil(rot.w / unit);
              if (x+dx>gridX || y+dy>gridY || z+dz>gridZ) continue;
              let canPlace = true;
              for (let xi = x; xi < x+dx && canPlace; xi++)
                for (let yi = y; yi < y+dy && canPlace; yi++)
                  for (let zi = z; zi < z+dz && canPlace; zi++)
                    if (grid[xi][yi][zi]) canPlace = false;
              if (!canPlace) continue;
              for (let xi = x; xi < x+dx; xi++)
                for (let yi = y; yi < y+dy; yi++)
                  for (let zi = z; zi < z+dz; zi++)
                    grid[xi][yi][zi] = idCounter;
              const pos = [x*unit + rot.l/2, y*unit + rot.h/2, container.xOffset + z*unit + rot.w/2];
              const geometry = new THREE.BoxGeometry(rot.l, rot.h, rot.w);
              const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), transparent: true, opacity: 1 });
              const box = new THREE.Mesh(geometry, material);
              box.position.set(...pos);
              box.userData.key = item.key;
              mainGroup.add(box);
              boxMeshes.push(box);
              boxCache.push({ l: rot.l, h: rot.h, w: rot.w, color, position: pos, key: item.key });
              idCounter++; placed = true;
              break outer;
            }
          }
        }
      }
      if (!placed) failedMap[item.key] = (failedMap[item.key] || 0) + 1;
    }
  });
  return result;
  return boxCache;
}
function drawContainerWireframe(type, index) {
  const size = containerSizeMap[type];
  const material = new THREE.LineBasicMaterial({ color: 0x000000 });
  const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
  const edges = new THREE.EdgesGeometry(geometry);
  const line = new THREE.LineSegments(edges, material);
  const xOffset = index === 0 ? 0 : containerOffsets[index - 1] + containerSizeMap[data[index - 1].type].width + 200;
  containerOffsets[index] = xOffset + size.width;
  line.position.set(size.length / 2, size.height / 2, xOffset + size.width / 2);
  mainGroup.add(line);
  return { xOffset, size };
}
window.addEventListener("message", (event) => {
  if (event.data?.type === "RENDER_CONTAINER") renderFromData(event.data.payload);
});
function animate() {
  requestAnimationFrame(animate);
  controls.update(); renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Container Visualizer — Instanced + Stair A→C + Step Animation</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:system-ui,Arial}
  #ui{position:absolute;left:12px;top:12px;z-index:10;background:#ffffffcc;border:1px solid #ddd;border-radius:10px;padding:10px;backdrop-filter:blur(4px)}
  #ui .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  #ui button{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer}
  #ui button:active{transform:translateY(1px)}
  #ui input[type=range]{width:140px}
  #stats{font:12px/1.2 monospace;color:#333;margin-top:6px}
  #report{position:absolute;left:0;right:0;bottom:0;max-height:34%;overflow:auto;background:#fff;border-top:2px solid #000;padding:8px;font:13px/1.4 monospace}
  canvas{display:block}
</style>
</head>
<body>
<div id="ui">
  <div><strong>Controls</strong></div>
  <div class="row">
    <button id="btnPlay">▶ Play</button>
    <button id="btnPause">⏸ Pause</button>
    <button id="btnStep">⏩ Step</button>
    <button id="btnReset">↺ Reset</button>
  </div>
  <div class="row">
    Speed <input id="speed" type="range" min="1" max="2000" value="500"> <span id="speedVal">500</span> box/s
  </div>
  <div id="stats">boxes: 0 | batches: 0 | fps: —</div>
</div>
<div id="report"></div>
<canvas id="three"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.0/examples/js/controls/OrbitControls.js"></script>
<script>
/* ========================= Config ========================= */
const UNIT = 10;                 // mm per sel grid
const GAP  = 2;                  // celah visual antar box (mm)
const MAX_INST = 60000;          // instanced per batch
const containerSizeMap = {
  "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
  "40FT (GP)": { length:12032, width: 2352, height: 2393 },
  "40FT (HQ)": { length:12032, width: 2352, height: 2698 }
};
/* ========================= Three.js ========================= */
const canvas = document.getElementById('three');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 200000);
camera.position.set(9000, 6000, 11000);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff, 0.9));
const sun = new THREE.DirectionalLight(0xffffff, 0.35);
sun.position.set(1,2,1);
scene.add(sun);

const root = new THREE.Group();
scene.add(root);

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ========================= Caches ========================= */
const geomCache = new Map(); // `${l}x${h}x${w}` -> BoxGeometry shrinked by GAP
const matCache  = new Map(); // color -> MeshStandardMaterial (vertexColors)
function getGeom(l,h,w){
  const L=Math.max(1,l-2*GAP), H=Math.max(1,h-2*GAP), W=Math.max(1,w-2*GAP);
  const key=`${L}x${H}x${W}`;
  if(!geomCache.has(key)) geomCache.set(key,new THREE.BoxGeometry(L,H,W));
  return geomCache.get(key);
}
function getMat(color){
  const key=color.toLowerCase();
  if(!matCache.has(key)){
    const m=new THREE.MeshStandardMaterial({color:new THREE.Color(key), roughness:.65, metalness:0});
    m.vertexColors=true; // kita pakai instanceColor untuk “fade”
    matCache.set(key,m);
  }
  return matCache.get(key);
}

/* ============ Instancing buckets (per size+color) ============ */
class Bucket {
  constructor(l,h,w,color){
    this.key=`${l}|${h}|${w}|${color}`;
    this.geom=getGeom(l,h,w);
    this.mat=getMat(color);
    this.batches=[]; // InstancedMesh[]
    this.counts=[];  // count per batch
  }
  _newBatch(){
    const mesh = new THREE.InstancedMesh(this.geom, this.mat, MAX_INST);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    const colors = new THREE.InstancedBufferAttribute(new Float32Array(MAX_INST*3), 3);
    mesh.geometry.setAttribute('instanceColor', colors);
    root.add(mesh);
    this.batches.push(mesh);
    this.counts.push(0);
  }
  add(matrix, rgb){
    if(!this.batches.length || this.counts[this.counts.length-1]>=MAX_INST) this._newBatch();
    const b=this.batches.length-1, i=this.counts[b]++;
    this.batches[b].setMatrixAt(i, matrix);
    const arr=this.batches[b].geometry.attributes.instanceColor.array;
    arr[3*i]=rgb.r; arr[3*i+1]=rgb.g; arr[3*i+2]=rgb.b;
    this.batches[b].count=this.counts[b];
    this.batches[b].instanceMatrix.needsUpdate=true;
    this.batches[b].geometry.attributes.instanceColor.needsUpdate=true;
  }
}
const buckets = new Map();
const getBucket=(l,h,w,color)=>{
  const key=`${l}|${h}|${w}|${color}`;
  if(!buckets.has(key)) buckets.set(key,new Bucket(l,h,w,color));
  return buckets.get(key);
};

/* =================== Wireframe container =================== */
function addWire(size, zOffset){
  const g=new THREE.BoxGeometry(size.length, size.height, size.width);
  const e=new THREE.EdgesGeometry(g);
  const w=new THREE.LineSegments(e, new THREE.LineBasicMaterial({color:0x000000}));
  w.position.set(size.length/2, size.height/2, zOffset+size.width/2);
  root.add(w);
}

/* ============ Packing (A→C: along X, front→back) ============ */
function getRotations(dim){
  const {length:l,width:w,height:h}=dim;
  return [
    {l,w,h},
    {l:w, w:h, h:l},
    {l:h, w:l, h:w},
  ];
}
/** menghasilkan steps: [{l,h,w,color, x,y,z, key}] */
function packContainer(containerType, items, zOffset){
  const size = containerSizeMap[containerType];
  const gx=Math.floor(size.length/UNIT), gy=Math.floor(size.height/UNIT), gz=Math.floor(size.width/UNIT);
  const occ=new Uint8Array(gx*gy*gz);
  const idx=(x,y,z)=>(y*gz+z)*gx+x;

  // profil tangga: makin ke belakang (x besar) makin rendah
  const STEP=0.4;
  const maxYAtX=new Int32Array(gx);
  for(let x=0;x<gx;x++) maxYAtX[x]=Math.max(1, Math.floor(gy - x*STEP));

  // urutkan: alas besar → volume → berat
  items.sort((a,b)=>{
    const bestA = getRotations(a.dimensions).reduce((m,r)=>Math.max(m, r.l*r.w),0);
    const bestB = getRotations(b.dimensions).reduce((m,r)=>Math.max(m, r.l*r.w),0);
    if(bestA!==bestB) return bestB-bestA;
    const volA=a.dimensions.l*a.dimensions.w*a.dimensions.h;
    const volB=b.dimensions.l*b.dimensions.w*b.dimensions.h;
    if(volA!==volB) return volB-volA;
    return (b.weight||1)-(a.weight||1);
  });

  const steps=[]; const failed={};
  function tryPlace(rot){
    const dx=Math.ceil(rot.l/UNIT), dy=Math.ceil(rot.h/UNIT), dz=Math.ceil(rot.w/UNIT);
    for(let y=0;y+dy<=gy;y++){
      for(let x=0;x+dx<=gx;x++){
        // tangga
        let ok=true; for(let xi=x;xi<x+dx && ok;xi++) if(y+dy>maxYAtX[xi]) ok=false;
        if(!ok) continue;
        for(let z=0;z+dz<=gz;z++){
          // free test
          let free=true;
          for(let xi=x;xi<x+dx && free;xi++)
            for(let yi=y;yi<y+dy && free;yi++)
              for(let zi=z;zi<z+dz && free;zi++) if(occ[idx(xi,yi,zi)]) free=false;
          if(!free) continue;
          // support (tidak boleh melayang)
          if(y>0){
            let sup=true;
            for(let xi=x;xi<x+dx && sup;xi++)
              for(let zi=z;zi<z+dz && sup;zi++) if(!occ[idx(xi,y-1,zi)]) sup=false;
            if(!sup) continue;
          }
          // mark
          for(let xi=x;xi<x+dx;xi++)
            for(let yi=y;yi<y+dy;yi++)
              for(let zi=z;zi<z+dz;zi++) occ[idx(xi,yi,zi)]=1;
          // world center
          return {
            x: x*UNIT + rot.l/2,
            y: y*UNIT + rot.h/2,
            z: zOffset + z*UNIT + rot.w/2
          };
        }
      }
    }
    return null;
  }

  items.forEach(item=>{
    for(let q=0;q<item.qty;q++){
      const rots=getRotations(item.dimensions)
        .sort((a,b)=>(b.l*b.w - a.l*a.w) || (a.h - b.h));
      let placed=null;
      for(const r of rots){ placed=tryPlace(r); if(placed){ steps.push({l:r.l,h:r.h,w:r.w,color:item.color||'#d26',key:item.key, ...placed}); break; } }
      if(!placed) failed[item.key]=(failed[item.key]||0)+1;
    }
  });

  return {steps, failed, size};
}

/* ============== Animator (chunked per frame) ============== */
const queue = []; // step objects to draw
let animOn=false, boxesDrawn=0;

function flushOne(step){
  const dummy=new THREE.Object3D();
  dummy.position.set(step.x, step.y, step.z);
  dummy.updateMatrix();
  const rgb=new THREE.Color(step.color);
  getBucket(step.l, step.h, step.w, step.color).add(dummy.matrix, rgb);
  boxesDrawn++;
}
function animate(time){
  requestAnimationFrame(animate);
  controls.update();

  // draw chunk per frame
  if(animOn && queue.length){
    const targetPerSec = Number(speedEl.value);
    const perFrame = Math.max(1, Math.floor(targetPerSec * (renderer.info.render.frameTime||16.7)/1000)) || 1;
    for(let i=0;i<perFrame && queue.length;i++) flushOne(queue.shift());
    needsHUD=true;
  }
  renderer.render(scene,camera);
  if(needsHUD){ updateStats(); needsHUD=false; }
}
let needsHUD=true;

/* ============== UI / Driver ============== */
const btnPlay = document.getElementById('btnPlay');
const btnPause= document.getElementById('btnPause');
const btnStep = document.getElementById('btnStep');
const btnReset= document.getElementById('btnReset');
const speedEl = document.getElementById('speed');
const speedVal= document.getElementById('speedVal');
const statsEl = document.getElementById('stats');
const reportEl= document.getElementById('report');

speedEl.addEventListener('input', ()=>{ speedVal.textContent=speedEl.value; });

btnPlay.onclick = ()=>{ animOn=true; };
btnPause.onclick= ()=>{ animOn=false; };
btnStep.onclick = ()=>{ if(queue.length){ flushOne(queue.shift()); updateStats(); renderer.render(scene,camera);} };
btnReset.onclick= ()=>{
  // clear scene/buckets
  for(const b of buckets.values()){
    b.batches.forEach(m=>{
      if(m.geometry) m.geometry.dispose();
      if(m.material) m.material.dispose();
      root.remove(m);
    });
  }
  buckets.clear(); queue.length=0; boxesDrawn=0; animOn=false;
  // keep container wires (child[0]..?) easiest: remove all, rebuild on next render payload
  [...root.children].forEach(c=>root.remove(c));
  updateStats();
};

function updateStats(){
  let batches=0; buckets.forEach(b=>batches+=b.batches.length);
  statsEl.textContent = `boxes: ${boxesDrawn} | batches: ${batches} | fps: ~${Math.round(renderer.info.render.frameTime?1000/renderer.info.render.frameTime:60)}`;
}

/* ============== Bridge: receive payload ============== */
/* Payload bentuk:
[
  {
    type: "40FT (HQ)",
    items: [
      { model:"FQ803", size:29, qty:100, weight: 10, color:"#e26",
        dimensions:{ l:1000, w:800, h:600 } },
      ...
    ]
  },
  ...
]
*/
addEventListener('message', (e)=>{
  if(e.data?.type!=='RENDER_CONTAINER') return;
  // reset
  btnReset.click();

  const payload=e.data.payload;
  let zOffset=0;
  let reports=[];
  payload.forEach((containerObj, ci)=>{
    const {steps, failed, size}=packContainer(containerObj.type,
      containerObj.items.map((it,idx)=>({...it, key:`${it.model} ${it.size}" (C${ci+1}-L${idx+1})`})),
      zOffset
    );
    // push steps to global queue
    queue.push(...steps);
    // wire
    addWire(size, zOffset);
    zOffset += size.width + 200;

    // report
    let text=`Container ${ci+1}: ${containerObj.type}\n`;
    if(Object.keys(failed).length){
      for(const [k,v] of Object.entries(failed)) text += `❌ ${k} tidak muat ${v} pcs\n`;
    } else text += '✅ Semua box berhasil dimuat\n';
    reports.push(text);
  });
  reportEl.textContent = reports.join('\n');
  updateStats();
});

/* ============== Kick render loop ============== */
requestAnimationFrame(animate);

/* ======= Demo (hapus ini di produksi) ======= */
setTimeout(()=>{
  // contoh kecil untuk melihat animasi jalan
  const demo=[{
    type:"40FT (HQ)",
    items:[
      {model:"BOX-A", size:30, qty:400, weight:10, color:"#ff7f7f", dimensions:{length:600,width:400,height:300}},
      {model:"BOX-B", size:50, qty:200, weight:12, color:"#7fbfff", dimensions:{length:800,width:600,height:400}},
      {model:"BOX-C", size:20, qty:150, weight:8,  color:"#ffd27f", dimensions:{length:500,width:400,height:300}},
    ]
  }];
  postMessage({type:'RENDER_CONTAINER', payload:demo}, '*');
}, 200);
</script>
</body>
</html>

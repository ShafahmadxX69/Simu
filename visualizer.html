<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer — Static Instanced (Stair A→C)</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #sidebar {
      position: absolute; top: 0; left: 0;
      width: 260px; height: 100%; overflow-y: auto;
      background:#f7f7f7; border-right:1px solid #ddd; padding:10px; box-sizing:border-box; z-index:10;
    }
    .containerBox { background:#fff; border:1px solid #e4e4e4; padding:10px; margin-bottom:10px; border-radius:8px; }
    .itemEntry { display:flex; gap:6px; align-items:center; margin:6px 0; }
    .itemEntry input { transform: scale(1.1); }
    #reportContainer {
      position:absolute; left:260px; right:0; bottom:0; max-height:32%;
      background:rgba(255,255,255,0.96); border-top:2px solid #000;
      font:13px/1.4 monospace; display:flex; flex-wrap:wrap; z-index:5; overflow-y:auto;
    }
    .reportBox { flex:1 1 240px; border:1px solid #e4e4e4; background:#fcfcfc; margin:6px; padding:10px; white-space:pre-wrap; border-radius:8px; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Container List</h3>
    <div id="containerList"></div>
  </div>
  <div id="reportContainer"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ====== KONFIG ======
  const containerSizeMap = {
    "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
    "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
    "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
  };
  const UNIT = 10;                     // ukuran grid mm (10mm = cukup rapat, masih cepat)
  const MAX_INSTANCES_PER_BATCH = 100000; // batch instancing
  const STAIR_SLOPE = 0.4;             // kemiringan tangga: makin besar => makin cepat menurun

  // ====== THREE BOOTSTRAP (tanpa animasi) ======
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 200000);
  camera.position.set(8000, 5200, 9600);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0xffffff, 0.95));
  const dir = new THREE.DirectionalLight(0xffffff, 0.35); dir.position.set(1,2,1); scene.add(dir);

  const mainGroup = new THREE.Group(); scene.add(mainGroup);

  let needsRender = true;
  function requestRender(){ needsRender = true; }
  function renderOnce(){ if (needsRender){ controls.update(); renderer.render(scene, camera); needsRender=false; } }
  // redraw saat interaksi saja
  controls.addEventListener('change', requestRender);
  (function raf(){ requestAnimationFrame(raf); renderOnce(); })();

  // ====== UTIL ======
  function clearScene(){
    mainGroup.traverse(obj => {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material){
        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose()); else obj.material.dispose();
      }
    });
    mainGroup.clear();
  }

  // caches
  const geomCache = new Map();   // `${l}x${h}x${w}` -> BoxGeometry
  const matCache  = new Map();   // color -> MeshStandardMaterial
  function getBoxGeometry(l,h,w){
    const key = `${l}x${h}x${w}`;
    if (!geomCache.has(key)) geomCache.set(key, new THREE.BoxGeometry(l,h,w));
    return geomCache.get(key);
  }
  function getMaterial(color){
    const key = color.toLowerCase();
    if (!matCache.has(key)){
      const m = new THREE.MeshStandardMaterial({ color: new THREE.Color(key), roughness:0.7, metalness:0.0 });
      matCache.set(key, m);
    }
    return matCache.get(key);
  }

  // wireframe kontainer (tipis, 1 per kontainer)
  function drawContainerWireframe(type, index, parent, prevOffsets, payload){
    const size = containerSizeMap[type];
    const geo = new THREE.BoxGeometry(size.length, size.height, size.width);
    const edges = new THREE.EdgesGeometry(geo);
    const wire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, transparent:true, opacity:0.7 }));
    const zOffset = index === 0 ? 0 : prevOffsets[index-1] + containerSizeMap[payload[index-1].type].width + 200;
    prevOffsets[index] = zOffset + size.width;
    wire.position.set(size.length/2, size.height/2, zOffset + size.width/2);
    parent.add(wire);
    return { zOffset, size };
  }

  function getRotations(dim){
    const { length:l, width:w, height:h } = dim;
    return [
      { l, w, h },
      { l:w, w:h, h:l },
      { l:h, w:l, h:w },
    ];
  }

  // ====== INSTANCING ======
  function InstanceBucket(l,h,w,color){
    this.key = `${l}|${h}|${w}|${color}`;
    this.geom = getBoxGeometry(l,h,w);
    this.mat  = getMaterial(color);
    this.batches = [];
    this.counts  = [];
  }
  InstanceBucket.prototype._ensure = function(){
    const mesh = new THREE.InstancedMesh(this.geom, this.mat, MAX_INSTANCES_PER_BATCH);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    this.batches.push(mesh);
    this.counts.push(0);
    mainGroup.add(mesh);
  };
  InstanceBucket.prototype.add = function(matrix){
    if (this.batches.length===0 || this.counts[this.counts.length-1] >= MAX_INSTANCES_PER_BATCH) this._ensure();
    const b = this.batches.length-1, i = this.counts[b]++;
    this.batches[b].setMatrixAt(i, matrix);
    this.batches[b].count = this.counts[b];
  };

  const buckets = new Map();
  function getBucket(l,h,w,color){
    const key = `${l}|${h}|${w}|${color}`;
    if (!buckets.has(key)) buckets.set(key, new InstanceBucket(l,h,w,color));
    return buckets.get(key);
  }

  // ====== PACKING: Tangga A→C, anti melayang, besar/bobot di bawah ======
  function smartPlaceBoxes(container, items, failedMap, addInstance){
    const { size, zOffset } = container;
    const gx = Math.floor(size.length / UNIT);   // X (depan A → belakang C)
    const gy = Math.floor(size.height / UNIT);   // Y (atas)
    const gz = Math.floor(size.width  / UNIT);   // Z (kiri-kanan)

    const occ = new Uint8Array(gx * gy * gz);
    const idx = (x,y,z) => (y*gz + z)*gx + x;

    // tangga: makin ke C (x besar) makin rendah
    const maxYAtX = new Int32Array(gx);
    for (let x=0; x<gx; x++) maxYAtX[x] = Math.max(1, Math.floor(gy - x*STAIR_SLOPE));

    // urutkan: alas terbesar → volume → berat
    items.sort((a,b)=>{
      const bestA = getRotations(a.dimensions).reduce((m,r)=>Math.max(m, r.l*r.w), 0);
      const bestB = getRotations(b.dimensions).reduce((m,r)=>Math.max(m, r.l*r.w), 0);
      if (bestA !== bestB) return bestB - bestA;
      const volA = a.dimensions.l*a.dimensions.w*a.dimensions.h;
      const volB = b.dimensions.l*b.dimensions.w*b.dimensions.h;
      if (volA !== volB) return volB - volA;
      return (b.weight||1)-(a.weight||1);
    });

    function tryPlace(rot){
      const dx = Math.ceil(rot.l/UNIT), dy = Math.ceil(rot.h/UNIT), dz = Math.ceil(rot.w/UNIT);
      for (let y=0; y+dy<=gy; y++){
        for (let x=0; x+dx<=gx; x++){
          // stair cap
          let ok = true; for (let xi=x; xi<x+dx && ok; xi++) if (y+dy > maxYAtX[xi]) ok = false;
          if (!ok) continue;

          for (let z=0; z+dz<=gz; z++){
            // quick free check
            let free = true;
            for (let xi=x; xi<x+dx && free; xi++)
              for (let yi=y; yi<y+dy && free; yi++)
                for (let zi=z; zi<z+dz && free; zi++)
                  if (occ[idx(xi,yi,zi)]) free = false;
            if (!free) continue;

            // support (tidak boleh melayang)
            if (y>0){
              let supported = true;
              for (let xi=x; xi<x+dx && supported; xi++)
                for (let zi=z; zi<z+dz && supported; zi++)
                  if (!occ[idx(xi,y-1,zi)]) supported = false;
              if (!supported) continue;
            }

            // mark occupied
            for (let xi=x; xi<x+dx; xi++)
              for (let yi=y; yi<y+dy; yi++)
                for (let zi=z; zi<z+dz; zi++)
                  occ[idx(xi,yi,zi)] = 1;

            const px = x*UNIT + rot.l/2;
            const py = y*UNIT + rot.h/2;
            const pz = zOffset + z*UNIT + rot.w/2;
            return { px,py,pz };
          }
        }
      }
      return null;
    }

    // place all qty
    items.forEach(item=>{
      for (let q=0; q<item.qty; q++){
        const rotations = getRotations(item.dimensions);
        rotations.sort((a,b)=> (b.l*b.w - a.l*a.w) || (a.h - b.h)); // alas lebar & rendah diprioritaskan
        let placed = null, usedRot = null;
        for (const rot of rotations){ placed = tryPlace(rot); if (placed){ usedRot = rot; break; } }
        if (!placed){ failedMap[item.key] = (failedMap[item.key]||0)+1; continue; }
        addInstance(item, usedRot, placed);
      }
    });
  }

  function addInstanceFactory(){
    const dummy = new THREE.Object3D();
    return function(item, rot, placed){
      const color = (item.color || '#'+(Math.random()*0xFFFFFF|0).toString(16).padStart(6,'0'));
      const bucket = getBucket(rot.l, rot.h, rot.w, color);
      dummy.position.set(placed.px, placed.py, placed.pz);
      dummy.rotation.set(0,0,0);
      dummy.updateMatrix();
      bucket.add(dummy.matrix);
    }
  }

  // ====== PIPELINE ======
  function renderFromData(payload){
    clearScene();
    const edgesGroup = new THREE.Group(); mainGroup.add(edgesGroup);

    const containerListEl = document.getElementById('containerList');
    const reportEl = document.getElementById('reportContainer');
    containerListEl.innerHTML = ''; reportEl.innerHTML = '';

    const containerOffsets = [];
    const addInst = addInstanceFactory();

    payload.forEach((containerObj, cIndex) => {
      const cont = drawContainerWireframe(containerObj.type, cIndex, edgesGroup, containerOffsets, payload);

      const failedMap = {};
      const boxList = containerObj.items.map((i, idx) => ({
        ...i,
        key: `${i.model} ${i.size}" (C${cIndex+1}-L${idx+1})`
      }));

      smartPlaceBoxes(cont, boxList, failedMap, addInst);

      // Sidebar ringkas (tanpa filter—hemat CPU)
      const card = document.createElement('div'); card.className='containerBox';
      card.innerHTML = `<strong>Container ${cIndex+1} — ${containerObj.type}</strong><div style="font-size:12px;color:#666">Items: ${boxList.length}</div>`;
      containerListEl.appendChild(card);

      // Report
      let report = `Container ${cIndex+1}: ${containerObj.type}\n`;
      report += Object.keys(failedMap).length
        ? Object.entries(failedMap).map(([k,v]) => `❌ ${k} tidak muat ${v} pcs`).join('\n')
        : '✅ Semua box berhasil dimuat\n';
      const rb = document.createElement('div'); rb.className='reportBox'; rb.innerText = report;
      reportEl.appendChild(rb);
    });

    // satu render
    requestRender(); renderOnce();
  }

  // ====== BRIDGE ======
  window.addEventListener('message', (ev)=>{
    if (ev.data && ev.data.type === 'RENDER_CONTAINER') renderFromData(ev.data.payload);
  });

  // Resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    requestRender();
  });
  </script>
</body>
</html>

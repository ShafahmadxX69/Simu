<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Packing 3D Optimized Report</title>
  <style>
    body { margin: 0; overflow: hidden; background: white; }
    canvas { display: block; }
    #reportContainer {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(255,255,255,0.95);
      font-family: monospace;
      font-size: 13px;
      max-height: 40%;
      overflow-y: auto;
      display: flex;
      flex-wrap: wrap;
      border-top: 2px solid #000;
    }
    .reportBox {
      border: 1px solid #ccc;
      padding: 10px;
      margin: 5px;
      flex: 1 1 200px;
      background: #f9f9f9;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
<div id="reportContainer"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
  const containerSizeMap = {
    "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
    "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
    "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
  };

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 50000);
  camera.position.set(10000, 5000, 10000);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  const light = new THREE.AmbientLight(0xffffff, 1);
  scene.add(light);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  function clearScene() {
    mainGroup.clear();
  }

  function drawContainerWireframe(type, index) {
    const size = containerSizeMap[type];
    const group = new THREE.Group();
    const material = new THREE.LineBasicMaterial({ color: 0x000000 });
    const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, material);
    const xOffset = index * (size.length + 2000);
    line.position.set(xOffset + size.length / 2, size.height / 2, 0);
    group.add(line);
    mainGroup.add(group);
    return { xOffset, size };
  }

  function getRotations(dim) {
    const { length, width, height } = dim;
    return [
      { l: length, w: width, h: height },
      { l: length, w: height, h: width },
      { l: width, w: length, h: height },
      { l: width, w: height, h: length },
      { l: height, w: length, h: width },
      { l: height, w: width, h: length }
    ];
  }

  function smartPlaceBoxes(container, items, failedMap) {
    const unit = 50;
    const gridX = Math.floor(container.size.length / unit);
    const gridY = Math.floor(container.size.height / unit);
    const gridZ = Math.floor(container.size.width / unit);

    const safetyHeightLimit = container.size.height * 0.3;
    const grid = Array.from({ length: gridX }, () => Array.from({ length: gridY }, () => Array(gridZ).fill(null)));

    let idCounter = 1;

    const sortedItems = [...items].sort((a, b) => {
      const volA = a.dimensions.length * a.dimensions.width * a.dimensions.height;
      const volB = b.dimensions.length * b.dimensions.width * b.dimensions.height;
      return volB - volA;
    });

    sortedItems.forEach(item => {
      let failedCount = 0;
      const color = new THREE.Color(item.color || '#' + Math.floor(Math.random() * 16777215).toString(16));

      for (let q = 0; q < item.qty; q++) {
        let placed = false;

        outerLoop:
        for (let x = 0; x < gridX; x++) {
          const isBackZone = x > gridX * 0.75;
          for (let z = 0; z < gridZ; z++) {
            let currentY = 0;

            while (currentY < gridY) {
              if (isBackZone && currentY * unit > safetyHeightLimit) break;

              const rotations = getRotations(item.dimensions);
              let fitted = false;

              for (let rot of rotations) {
                const dx = Math.ceil(rot.l / unit);
                const dy = Math.ceil(rot.h / unit);
                const dz = Math.ceil(rot.w / unit);

                if (x + dx > gridX || currentY + dy > gridY || z + dz > gridZ) continue;

                const supported = currentY === 0 || grid[x][currentY - 1][z];
                let space = true;
                for (let xi = x; xi < x + dx && space; xi++)
                  for (let yi = currentY; yi < currentY + dy && space; yi++)
                    for (let zi = z; zi < z + dz && space; zi++)
                      if (grid[xi][yi][zi]) space = false;

                if (space && supported) {
                  for (let xi = x; xi < x + dx; xi++)
                    for (let yi = currentY; yi < currentY + dy; yi++)
                      for (let zi = z; zi < z + dz; zi++)
                        grid[xi][yi][zi] = idCounter;

                  const zStart = -container.size.width / 2;
                  const boxZ = zStart + z * unit + rot.w / 2;

                  const box = new THREE.Mesh(
                    new THREE.BoxGeometry(rot.l, rot.h, rot.w),
                    new THREE.MeshStandardMaterial({ color })
                  );
                  box.position.set(
                    container.xOffset + x * unit + rot.l / 2,
                    currentY * unit + rot.h / 2,
                    boxZ
                  );
                  mainGroup.add(box);

                  const edges = new THREE.EdgesGeometry(box.geometry);
                  const wire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                  wire.position.copy(box.position);
                  mainGroup.add(wire);

                  idCounter++;
                  fitted = true;
                  placed = true;
                  break outerLoop;
                }
              }

              if (fitted) break;
              currentY++;
            }
          }
        }

        if (!placed) {
          const key = `${item.model} ${item.size}"`;
          failedMap[key] = (failedMap[key] || 0) + 1;
        }
      }
    });
  }

  function renderFromData(data) {
    clearScene();
    const reportContainer = document.getElementById("reportContainer");
    reportContainer.innerHTML = "";

    data.forEach((containerObj, index) => {
      const container = drawContainerWireframe(containerObj.type, index);
      const failedMap = {};

      const boxes = containerObj.items.map(i => ({
        model: i.model,
        size: i.size,
        qty: i.qty,
        color: i.color,
        dimensions: i.dimensions
      }));

      smartPlaceBoxes(container, boxes, failedMap);

      let reportText = `Container ${index + 1}: ${containerObj.type}\n`;
      if (Object.keys(failedMap).length === 0) {
        reportText += `✅ Semua box berhasil dimuat\n`;
      } else {
        for (const [key, val] of Object.entries(failedMap)) {
          reportText += `❌ ${key} tidak muat ${val} pcs\n`;
        }
      }

      const reportBox = document.createElement("div");
      reportBox.className = "reportBox";
      reportBox.innerText = reportText;
      reportContainer.appendChild(reportBox);
    });
  }

  window.addEventListener("message", (event) => {
    if (event.data && event.data.type === "RENDER_CONTAINER") {
      renderFromData(event.data.payload);
    }
  });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
